---
phase: 08.2-audit-remediation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/platforms/macos/install/homebrew.sh
  - src/platforms/macos/main.sh
  - src/platforms/linux/main.sh
  - src/platforms/windows/core/errors.psm1
  - setup.ps1
autonomous: true

must_haves:
  truths:
    - "homebrew.sh exits 1 when Homebrew installation fails (exception to always-exit-0)"
    - "homebrew.sh writes to FAILURE_LOG when install fails and FAILURE_LOG is set"
    - "macOS main.sh cleanup reads FAILURE_LOG and reports child process failures"
    - "Linux main.sh cleanup reads FAILURE_LOG and reports child process failures"
    - "PowerShell Add-FailedItem writes to $env:FAILURE_LOG when available"
    - "setup.ps1 creates $env:FAILURE_LOG temp file and reads it at exit for summary"
  artifacts:
    - path: "src/platforms/macos/install/homebrew.sh"
      provides: "Exit code propagation for hard prerequisite"
      contains: "exit 1"
    - path: "src/platforms/macos/main.sh"
      provides: "Failure aggregation from child processes"
      contains: "FAILURE_LOG"
    - path: "src/platforms/linux/main.sh"
      provides: "Failure aggregation from child processes"
      contains: "FAILURE_LOG"
    - path: "src/platforms/windows/core/errors.psm1"
      provides: "Cross-process failure tracking (write side)"
      contains: "FAILURE_LOG"
    - path: "setup.ps1"
      provides: "FAILURE_LOG lifecycle (create + read)"
      contains: "FAILURE_LOG"
  key_links:
    - from: "src/platforms/macos/main.sh"
      to: "src/platforms/macos/install/homebrew.sh"
      via: "bash call with || return 1"
      pattern: "homebrew.sh.*return 1"
    - from: "src/core/errors.sh"
      to: "FAILURE_LOG"
      via: "record_failure() file append"
      pattern: "FAILURE_LOG"
    - from: "setup.ps1"
      to: "src/platforms/windows/core/errors.psm1"
      via: "$env:FAILURE_LOG env var inherited by child processes"
      pattern: "FAILURE_LOG"
---

<objective>
Fix exit code propagation in homebrew.sh and add cross-process failure aggregation to all orchestrators.

Purpose: Homebrew is a hard prerequisite for all macOS installs. When it fails, the orchestrator must detect it. Additionally, orchestrators (macOS/Linux main.sh, Windows main.ps1) should aggregate failures from child processes via the FAILURE_LOG file pattern already in setup.sh.
Output: homebrew.sh with exit 1 on failure, orchestrator cleanup functions with FAILURE_LOG reading, PS errors.psm1 with file-based tracking
</objective>

<execution_context>
@/Users/bragatte/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bragatte/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/platforms/macos/install/homebrew.sh
@src/platforms/macos/main.sh
@src/platforms/linux/main.sh
@src/core/errors.sh
@src/core/progress.sh
@setup.sh
@src/platforms/windows/core/errors.psm1
@setup.ps1
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix homebrew.sh exit code propagation</name>
  <files>src/platforms/macos/install/homebrew.sh</files>
  <action>
Modify the main guard block (lines 178-192) in `src/platforms/macos/install/homebrew.sh`:

**Change the failure handling (lines 181-183):**
Replace:
```bash
    if ! install_homebrew; then
        log_error "Homebrew installation failed"
        exit 0  # Always exit 0 (per Phase 1 decision)
    fi
```
With:
```bash
    if ! install_homebrew; then
        log_error "Homebrew installation failed"
        # Exception to always-exit-0: Homebrew is a hard prerequisite
        # for all subsequent macOS installs. Signal failure to caller.
        if [[ -n "${FAILURE_LOG:-}" ]]; then
            echo "homebrew-install" >> "$FAILURE_LOG"
        fi
        exit 1
    fi
```

**Also change the final exit (lines 190-191):**
Keep `exit 0` for the success path (no change needed there).

**Update the comment on line 190:**
Replace:
```bash
    # Always exit 0 (per Phase 1 decision)
```
With:
```bash
    # Success path: exit 0
```

This is the ONLY exception to the always-exit-0 rule because Homebrew is a hard prerequisite. The macOS orchestrator (main.sh line 138) already checks `bash "${MACOS_DIR}/install/homebrew.sh" || return 1`, so this fix makes the existing check actually work.
  </action>
  <verify>
Run: `bash -n src/platforms/macos/install/homebrew.sh` (syntax valid)
Run: `grep -q "exit 1" src/platforms/macos/install/homebrew.sh` (exit 1 present)
Run: `grep -q "FAILURE_LOG" src/platforms/macos/install/homebrew.sh` (FAILURE_LOG write present)
  </verify>
  <done>homebrew.sh exits 1 on Homebrew install failure and writes to FAILURE_LOG. Success path still exits 0.</done>
</task>

<task type="auto">
  <name>Task 2: Add failure aggregation to orchestrator cleanup functions</name>
  <files>
    src/platforms/macos/main.sh
    src/platforms/linux/main.sh
    src/platforms/windows/core/errors.psm1
    setup.ps1
  </files>
  <action>
**macOS main.sh (lines 56-61):**
Replace the cleanup function:
```bash
cleanup() {
    local exit_code=$?
    [[ $exit_code -ne 0 ]] && log_info "Exiting ${SCRIPT_NAME} with code $exit_code"
    exit $exit_code
}
```
With:
```bash
cleanup() {
    local exit_code=$?

    # Aggregate failures from child processes via shared log
    if [[ -n "${FAILURE_LOG:-}" && -f "$FAILURE_LOG" && -s "$FAILURE_LOG" ]]; then
        log_warn "Child process failures detected:"
        while IFS= read -r item; do
            echo "  - $item"
        done < "$FAILURE_LOG"
    fi

    [[ $exit_code -ne 0 ]] && log_info "Exiting ${SCRIPT_NAME} with code $exit_code"
    exit $exit_code
}
```

**Linux main.sh (lines 56-61):**
Apply the SAME change to the cleanup function (identical pattern).

**PowerShell errors.psm1 (Add-FailedItem function, lines 19-37):**
Add file-based cross-process tracking to the `Add-FailedItem` function. After the existing `$script:FailedItems += $Item` line and `Write-Log` call, add:

```powershell
    # Cross-process tracking via shared file (matches Bash FAILURE_LOG pattern)
    if ($env:FAILURE_LOG -and (Test-Path (Split-Path $env:FAILURE_LOG -ErrorAction SilentlyContinue) -ErrorAction SilentlyContinue)) {
        Add-Content -Path $env:FAILURE_LOG -Value $Item -Encoding UTF8
    }
```

This addition goes INSIDE the `Add-FailedItem` function body, after the `Write-Log -Level ERROR -Message "Failed: $Item"` line.

Do NOT change the Export-ModuleMember line. Do NOT change any other functions.

**PowerShell setup.ps1 (FAILURE_LOG lifecycle):**
This mirrors the Bash `setup.sh` pattern where setup.sh creates FAILURE_LOG and reads it at the end.

1. After the `Import-Module` lines (line 41) and before the banner (line 44), add FAILURE_LOG creation:

```powershell
# Cross-process failure tracking (mirrors Bash FAILURE_LOG pattern)
$env:FAILURE_LOG = Join-Path ([System.IO.Path]::GetTempPath()) "ospostinstall-failures-$PID.log"
```

2. Before `Write-Log -Level BANNER -Message 'Setup Complete'` (line 61), add FAILURE_LOG reading:

```powershell
# Aggregate failures from child processes via shared log
if ($env:FAILURE_LOG -and (Test-Path $env:FAILURE_LOG)) {
    $failures = Get-Content $env:FAILURE_LOG -ErrorAction SilentlyContinue
    if ($failures) {
        Write-Log -Level WARN -Message "Child process failures detected:"
        foreach ($item in $failures) {
            Write-Host "    - $item"
        }
    }
    Remove-Item $env:FAILURE_LOG -Force -ErrorAction SilentlyContinue
}
```

3. Update the existing comment block (lines 57-60) that says "Show-FailureSummary NOT called here" to:

```powershell
# Failure aggregation via $env:FAILURE_LOG file (cross-process tracking)
# Child processes write to this file via Add-FailedItem in errors.psm1
```

This closes the Windows FAILURE_LOG lifecycle: setup.ps1 creates -> child processes write via errors.psm1 -> setup.ps1 reads and cleans up.
  </action>
  <verify>
Run: `bash -n src/platforms/macos/main.sh` (syntax valid)
Run: `bash -n src/platforms/linux/main.sh` (syntax valid)
Run: `grep -q "FAILURE_LOG" src/platforms/macos/main.sh` (FAILURE_LOG reading present)
Run: `grep -q "FAILURE_LOG" src/platforms/linux/main.sh` (FAILURE_LOG reading present)
Run: `grep -q "FAILURE_LOG" src/platforms/windows/core/errors.psm1` (FAILURE_LOG writing present)
Run: `grep -q "FAILURE_LOG" setup.ps1` (FAILURE_LOG lifecycle present)
  </verify>
  <done>Both Bash orchestrators aggregate child failures via FAILURE_LOG in cleanup. PowerShell errors.psm1 writes to $env:FAILURE_LOG. setup.ps1 creates and reads FAILURE_LOG (full lifecycle).</done>
</task>

</tasks>

<verification>
1. `bash -n src/platforms/macos/install/homebrew.sh` passes
2. `bash -n src/platforms/macos/main.sh` passes
3. `bash -n src/platforms/linux/main.sh` passes
4. `grep -q "exit 1" src/platforms/macos/install/homebrew.sh` passes
5. `grep -c "FAILURE_LOG" src/platforms/macos/main.sh` returns >= 1
6. `grep -c "FAILURE_LOG" src/platforms/linux/main.sh` returns >= 1
7. `grep -c "FAILURE_LOG" src/platforms/windows/core/errors.psm1` returns >= 1
8. `grep -c "FAILURE_LOG" setup.ps1` returns >= 2 (create + read)
</verification>

<success_criteria>
- homebrew.sh exits 1 on failure (exception to always-exit-0 for hard prerequisites)
- macOS/Linux orchestrators read FAILURE_LOG in cleanup and report child failures
- PowerShell Add-FailedItem writes to $env:FAILURE_LOG file when available
- setup.ps1 creates FAILURE_LOG, reads at exit, cleans up (full Windows lifecycle)
- All files pass syntax validation
</success_criteria>

<output>
After completion, create `.planning/phases/08.2-audit-remediation/08.2-02-SUMMARY.md`
</output>
