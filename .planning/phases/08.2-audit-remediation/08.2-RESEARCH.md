# Phase 8.2: Audit Remediation - Research

**Researched:** 2026-02-08
**Domain:** Shell scripting remediation (Bash + PowerShell), manual test harnesses, cross-process failure tracking
**Confidence:** HIGH (all findings from direct codebase analysis)

## Summary

This phase addresses 7 priority items from a 4-agent codebase audit. The codebase already has strong established patterns (data-driven installers, idempotency guards, failure tracking via `FAILED_ITEMS[]`, NO_COLOR support, DRY_RUN guards) that can be reused rather than invented. The primary challenge is not "how to build" but "how to fit remediation into existing architecture decisions."

The most significant item is `post_install.sh` (10+ bugs, deprecated patterns), which should be deprecated-in-place with a clear notice rather than migrated. It was already superseded by the modern `main.sh` + data-driven installer architecture in Phases 2-5. The remaining items are surgical fixes to existing scripts (exit code propagation, dry-run guards, dispatch expansion) plus new test files that follow the already-established `test-linux.sh` and `test-dotfiles.sh` patterns.

**Primary recommendation:** Deprecate `post_install.sh` with a wrapper that prints a migration notice and exits. Apply surgical fixes to 5 existing files. Create 2 new test files following established patterns. Create `CODE_OF_CONDUCT.md` from Contributor Covenant v2.1 template.

## Standard Stack

### Core

| Tool | Version | Purpose | Why Standard |
|------|---------|---------|--------------|
| Bash | 3.2+ (macOS compat) | All shell scripts | Project constraint: zero external deps |
| PowerShell | 5.1+ | Windows scripts | `#Requires -Version 5.1` already enforced |
| POSIX utilities | System | grep, wc, mktemp, etc. | Available on all target platforms |

### Supporting

| Tool | Version | Purpose | When to Use |
|------|---------|---------|-------------|
| `bash -n` | Any | Syntax validation in tests | Static tests (test-linux.sh pattern) |
| `grep -q` / `grep -qP` | Any | Content/anti-pattern checks in tests | Static tests (test-linux.sh pattern) |
| `shellcheck` | Any | Optional linting | NOT required (manual tests only, no CI) |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Manual test harness | BATS (Bash Automated Testing System) | BATS adds external dep; project constraint is zero deps on clean machine |
| FAILURE_LOG file | Exit code arithmetic | File-based is already implemented in setup.sh; exit codes lose granularity |
| Full post_install.sh migration | Deprecation notice | Migration is 10+ hours for a file already superseded; deprecation is 10 minutes |

## Architecture Patterns

### Existing Project Structure (no changes needed)

```
src/
├── core/             # Shared modules: logging, errors, packages, idempotent, progress
├── install/          # Cross-platform installers: ai-tools, rust-cli, dev-env, fnm, uv
├── platforms/
│   ├── linux/
│   │   ├── main.sh          # Orchestrator (profile dispatch)
│   │   ├── post_install.sh  # LEGACY (deprecate)
│   │   └── install/         # apt.sh, flatpak.sh, snap.sh, cargo.sh
│   ├── macos/
│   │   ├── main.sh          # Orchestrator (profile dispatch)
│   │   └── install/         # homebrew.sh, brew.sh, brew-cask.sh
│   └── windows/
│       ├── main.ps1         # Orchestrator (profile dispatch)
│       ├── core/            # logging.psm1, packages.psm1, errors.psm1
│       └── install/         # winget.ps1
tests/
├── test-dotfiles.sh    # Integration tests (source module, assert helpers)
├── test-linux.sh       # Static tests (bash -n, grep -q, assert_pass/assert_fail)
└── test_harness.sh     # Structure/existence tests (pass/fail/skip helpers)
data/
└── packages/
    └── profiles/       # minimal.txt, developer.txt, full.txt
```

### Pattern 1: Deprecation-in-Place

**What:** Replace a legacy script with a thin wrapper that prints a deprecation notice and exits.
**When to use:** When a file has 10+ bugs but is already fully superseded by modern alternatives.
**Why not delete:** Users may have bookmarked or scripted references to the old path.
**Example:**
```bash
#!/usr/bin/env bash
# DEPRECATED: This script is superseded by the modern architecture.
# Use: ./setup.sh [profile]    (Linux/macOS entry point)
# Or:  src/platforms/linux/main.sh [profile]
#
# This file is retained for backward compatibility only.
# It will be removed in a future release.
echo ""
echo "[DEPRECATED] post_install.sh is no longer maintained."
echo ""
echo "  Use instead:"
echo "    ./setup.sh            # Interactive mode"
echo "    ./setup.sh developer  # Unattended mode"
echo ""
echo "  See: README.md for full usage instructions."
echo ""
exit 0
```

### Pattern 2: FAILURE_LOG Cross-Process Tracking (Already Exists)

**What:** setup.sh already creates `FAILURE_LOG="${TEMP_DIR}/failures.log"` and exports it. Child scripts call `record_failure()` which appends to this file.
**Where it works:** Any child script that sources `core/errors.sh` and writes to `FAILURE_LOG`.
**Where it breaks:** Child scripts run via `bash script.sh` (subshell) DO inherit `FAILURE_LOG` env var BUT each script re-declares `FAILED_ITEMS=()` locally. The `record_failure()` function in `errors.sh` already writes to `FAILURE_LOG` if set.
**Gap:** Orchestrators (`main.sh` on both platforms) do NOT read `FAILURE_LOG` at the end -- only `setup.sh` does. When run standalone (not via setup.sh), failures in child processes are lost.
**Fix:** Add `FAILURE_LOG` reading to orchestrator cleanup functions. The `show_completion_summary()` in `progress.sh` already supports this pattern (lines 105-109).

### Pattern 3: Static Test Suite (test-linux.sh Pattern)

**What:** Offline tests that validate syntax, content patterns, and anti-patterns without running installers.
**Structure:**
```bash
# Test runner setup
TESTS_PASSED=0; TESTS_FAILED=0; TESTS_TOTAL=0

assert_pass() { ... }   # Command must succeed
assert_fail() { ... }   # Command must fail (anti-pattern check)

# 1. Syntax checks: bash -n script.sh
# 2. Content checks: grep -q "pattern" script.sh
# 3. Anti-pattern checks: assert_fail grep -q "bad_pattern" script.sh
# 4. Summary and exit code
```

### Pattern 4: Windows Cross-Platform Dispatch (Expanding main.ps1 switch)

**What:** Expand the `switch ($pkgFile)` block in `main.ps1` to handle cargo.txt, npm.txt, and ai-tools.txt.
**Constraint:** Windows does not have `cargo.sh`, `npm.sh`, or `ai-tools.sh` equivalents in PowerShell yet.
**Approach:** For this phase, log a WARN message (not silent DEBUG skip) for cross-platform files that need future implementation. This makes the gap visible without breaking anything.
**Example:**
```powershell
switch ($pkgFile) {
    'winget.txt' {
        Write-Log -Level INFO -Message 'Installing WinGet packages...'
        & "$WindowsDir/install/winget.ps1"
    }
    'cargo.txt' {
        Write-Log -Level WARN -Message 'cargo.txt: Windows Cargo installer not yet implemented (skipping)'
    }
    'npm.txt' {
        Write-Log -Level WARN -Message 'npm.txt: Windows npm installer not yet implemented (skipping)'
    }
    'ai-tools.txt' {
        Write-Log -Level WARN -Message 'ai-tools.txt: Windows AI tools installer not yet implemented (skipping)'
    }
    default {
        Write-Log -Level DEBUG -Message "Skipping $pkgFile (not a Windows package file)"
    }
}
```

### Anti-Patterns to Avoid

- **Migrating post_install.sh line-by-line:** The modern architecture already replaces every function. Migration would take 10+ hours and produce a script identical to what already exists in `linux/main.sh` + child installers.
- **Adding set -e to fix error handling:** Prior decision [01-01] explicitly rejected set -e. Continue-on-failure is intentional.
- **Building a CI/CD pipeline:** Explicit owner decision -- NO CI/CD. Tests are manual only.
- **Creating PowerShell installer scripts for cargo/npm/ai-tools:** Out of scope for remediation. Log WARN for visibility, implement in a future phase.
- **Double-summary on cleanup:** The `_SUMMARY_SHOWN` guard pattern in `setup.sh` prevents this. Any new cleanup traps must respect it.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Cross-process failure tracking | Custom IPC mechanism | `FAILURE_LOG` env var + file append (already in errors.sh) | Already implemented, just not used everywhere |
| Test framework | Custom runner with fixtures | `assert_pass`/`assert_fail` from test-linux.sh pattern | Proven pattern, zero deps |
| Code of Conduct | Custom document | Contributor Covenant v2.1 markdown template | Industry standard, well-recognized |
| Deprecation mechanism | Version checks, compatibility layers | Simple wrapper script with echo + exit 0 | KISS: print message, done |
| DRY_RUN guard for curl\|sh | Custom download-then-execute wrapper | Existing `run()` function in terminal-setup.sh | Already defined, just not applied to all curl\|sh calls |
| PowerShell failure aggregation | Custom cross-process tracking | `$env:FAILURE_LOG` file approach (match Bash pattern) | Consistent with Bash architecture |

**Key insight:** Every fix in this phase is either "use an existing pattern the codebase already has" or "create a thin shim following an existing example." Nothing requires new architecture.

## Common Pitfalls

### Pitfall 1: Exit Code Masking in Always-Exit-0 Architecture

**What goes wrong:** homebrew.sh exits 0 even when `install_homebrew` fails (line 183: `exit 0  # Always exit 0`). The macOS orchestrator checks `bash "${MACOS_DIR}/install/homebrew.sh" || return 1` but never sees the failure.
**Why it happens:** Phase 1 decision [01-03] says "always exit 0, failures shown in summary." But this creates a conflict: orchestrators that check child exit codes never see failures.
**How to avoid:** For CRITICAL dependencies (like Homebrew, which all subsequent installs depend on), use `FAILURE_LOG` file-based signaling instead of exit codes. Homebrew failure should write to `FAILURE_LOG` AND the orchestrator should check the file, not the exit code.
**Alternative (simpler):** Change only homebrew.sh to exit 1 on actual install failure. The orchestrator already handles `|| return 1`. This is the exception to "always exit 0" because Homebrew is a hard prerequisite, not a package that can be skipped.
**Warning signs:** `exit 0` at the end of a script that checks `if ! some_function; then log_error "..."; exit 0; fi` -- the error is logged but the caller has no way to detect it.

### Pitfall 2: PowerShell Process Scope Isolation

**What goes wrong:** `$script:FailedItems` in errors.psm1 is process-scoped. When `winget.ps1` runs as a child process (`& "$WindowsDir/install/winget.ps1"`), its failures are invisible to main.ps1 and setup.ps1.
**Why it happens:** PowerShell module variables are scoped to the importing process. Child scripts started with `&` or `.` start fresh or import fresh modules.
**How to avoid:** Use file-based failure tracking (same as Bash `FAILURE_LOG` pattern). Set `$env:FAILURE_LOG` in setup.ps1, have errors.psm1 write to it, and read the file in the orchestrator cleanup.
**Warning signs:** Comments like "child scripts run in separate process scopes with their own failure tracking" (already noted in main.ps1 line 119-121 and setup.ps1 line 58-59).

### Pitfall 3: terminal-setup.sh Dry-Run Bypass

**What goes wrong:** Two `curl | sh` calls bypass the `run()` wrapper, executing even in dry-run mode.
**Where:**
- Line 181: `run curl -sSfL https://raw.githubusercontent.com/ajeetdsouza/zoxide/main/install.sh | sh` -- the `run` guards the curl but not the `sh` pipe. In dry-run, curl is suppressed but `sh` still runs (on empty input).
- Line 188: `run curl -sS https://starship.rs/install.sh | sh -s -- -y` -- same problem.
**Why it happens:** `run()` wraps the first command in the pipeline, but the pipe (`|`) creates a second command that runs unconditionally.
**How to avoid:** Wrap the ENTIRE pipeline: `run bash -c 'curl -sSfL URL | sh'` or check DRY_RUN before the pipeline and skip entirely.
**Warning signs:** Any `run CMD | CMD` pattern -- the run only guards the left side of the pipe.

### Pitfall 4: post_install.sh Security Issues

**What goes wrong:** The legacy script has multiple security issues that users may still run:
- Line 190: `sudo apt-key add -` (deprecated since apt 2.4, keys should go in `/etc/apt/keyrings/`)
- Line 207: `chmod 777 -R "$Dir_Downloads"` (world-writable directory)
- Line 204: `HOME="$(getent passwd $SUDO_USER | cut -d: -f6)"` (overwrites HOME variable)
- Unquoted `$Dir_Downloads` in glob (line 211)
**How to avoid:** Deprecate the entire file. Do not attempt to fix individual bugs -- the modern architecture already handles all these use cases correctly.

### Pitfall 5: Test Execution Requires Platform

**What goes wrong:** test-macos.sh static tests reference macOS-specific files. Running them on Linux would fail (files exist but `bash -n` might fail due to missing commands like `brew`).
**Why it happens:** `bash -n` only checks syntax, not runtime availability, so this is actually safe. But content checks that `grep` for patterns work on any platform.
**How to avoid:** Static tests (syntax + content checks) work cross-platform. Only runtime/integration tests need platform restriction. Add a platform guard at the top of integration-only tests.

### Pitfall 6: Double FAILED_ITEMS Declaration

**What goes wrong:** Both `errors.sh` (line 65) and individual scripts like `brew.sh` (line 93), `ai-tools.sh` (line 193) declare their own `FAILED_ITEMS=()`. When `errors.sh` is sourced AND the script declares locally, the local one shadows the shared one.
**Why it happens:** Each script was designed to be self-contained but also sources `errors.sh`.
**Impact on remediation:** When adding FAILURE_LOG support, ensure `record_failure()` from errors.sh is the one being called, not a local override. The `record_failure()` function already writes to FAILURE_LOG.

## Code Examples

### Example 1: Static Test Suite (for test-macos.sh)

```bash
#!/usr/bin/env bash
# test-macos.sh - Static tests for macOS platform scripts

TESTS_PASSED=0
TESTS_FAILED=0
TESTS_TOTAL=0

assert_pass() {
    local test_name="$1"; shift
    TESTS_TOTAL=$((TESTS_TOTAL + 1))
    if "$@" 2>/dev/null; then
        TESTS_PASSED=$((TESTS_PASSED + 1))
        echo "[PASS] $test_name"
    else
        TESTS_FAILED=$((TESTS_FAILED + 1))
        echo "[FAIL] $test_name"
    fi
}

assert_fail() {
    local test_name="$1"; shift
    TESTS_TOTAL=$((TESTS_TOTAL + 1))
    if "$@" 2>/dev/null; then
        TESTS_FAILED=$((TESTS_FAILED + 1))
        echo "[FAIL] $test_name"
    else
        TESTS_PASSED=$((TESTS_PASSED + 1))
        echo "[PASS] $test_name"
    fi
}

echo "========================================="
echo "  macOS Platform Tests"
echo "========================================="

# Syntax checks
assert_pass "homebrew.sh syntax" bash -n src/platforms/macos/install/homebrew.sh
assert_pass "brew.sh syntax" bash -n src/platforms/macos/install/brew.sh
assert_pass "brew-cask.sh syntax" bash -n src/platforms/macos/install/brew-cask.sh
assert_pass "macos main.sh syntax" bash -n src/platforms/macos/main.sh

# Content checks
assert_pass "MACOS_DIR used" grep -q "MACOS_DIR" src/platforms/macos/main.sh
assert_pass "brew prefix detection" grep -q "get_brew_prefix" src/platforms/macos/install/homebrew.sh
assert_pass "idempotent brew check" grep -q "is_brew_installed" src/platforms/macos/install/brew.sh
assert_pass "cask-specific check" grep -q "_is_cask_installed" src/platforms/macos/install/brew-cask.sh
assert_pass "DRY_RUN guard in homebrew" grep -q "DRY_RUN" src/platforms/macos/install/homebrew.sh

# Anti-pattern checks
assert_fail "no set -e in homebrew" grep -qP "^\s*set\s+-e" src/platforms/macos/install/homebrew.sh
assert_fail "no set -e in brew" grep -qP "^\s*set\s+-e" src/platforms/macos/install/brew.sh
assert_fail "no SCRIPT_DIR= in main" grep -q "^SCRIPT_DIR=" src/platforms/macos/main.sh

# Summary
echo "========================================="
echo "Results: $TESTS_PASSED passed, $TESTS_FAILED failed, $TESTS_TOTAL total"
echo "========================================="
[[ $TESTS_FAILED -eq 0 ]] && exit 0 || exit 1
```

### Example 2: PowerShell Static Test Suite (for test-windows.ps1)

```powershell
#Requires -Version 5.1
# test-windows.ps1 - Static tests for Windows platform scripts

$Passed = 0
$Failed = 0
$Total = 0

function Assert-Pass {
    param([string]$Name, [scriptblock]$Test)
    $script:Total++
    try {
        $result = & $Test 2>$null
        if ($LASTEXITCODE -eq 0 -or $result) {
            $script:Passed++
            Write-Host "[PASS] $Name"
        } else {
            $script:Failed++
            Write-Host "[FAIL] $Name"
        }
    } catch {
        $script:Failed++
        Write-Host "[FAIL] $Name"
    }
}

function Assert-Contains {
    param([string]$Name, [string]$Path, [string]$Pattern)
    $script:Total++
    if (Select-String -Path $Path -Pattern $Pattern -Quiet) {
        $script:Passed++
        Write-Host "[PASS] $Name"
    } else {
        $script:Failed++
        Write-Host "[FAIL] $Name"
    }
}

function Assert-NotContains {
    param([string]$Name, [string]$Path, [string]$Pattern)
    $script:Total++
    if (-not (Select-String -Path $Path -Pattern $Pattern -Quiet)) {
        $script:Passed++
        Write-Host "[PASS] $Name"
    } else {
        $script:Failed++
        Write-Host "[FAIL] $Name"
    }
}

Write-Host "========================================="
Write-Host "  Windows Platform Tests"
Write-Host "========================================="

# File existence
Assert-Pass "main.ps1 exists" { Test-Path 'src/platforms/windows/main.ps1' }
Assert-Pass "winget.ps1 exists" { Test-Path 'src/platforms/windows/install/winget.ps1' }
Assert-Pass "logging.psm1 exists" { Test-Path 'src/platforms/windows/core/logging.psm1' }
Assert-Pass "packages.psm1 exists" { Test-Path 'src/platforms/windows/core/packages.psm1' }
Assert-Pass "errors.psm1 exists" { Test-Path 'src/platforms/windows/core/errors.psm1' }

# Content checks
Assert-Contains "Write-Log in main" 'src/platforms/windows/main.ps1' 'Write-Log'
Assert-Contains "WinGet idempotent check" 'src/platforms/windows/install/winget.ps1' 'Test-WinGetInstalled'
Assert-Contains "ErrorActionPreference" 'src/platforms/windows/main.ps1' 'ErrorActionPreference'
Assert-Contains "Export-ModuleMember in errors" 'src/platforms/windows/core/errors.psm1' 'Export-ModuleMember'
Assert-Contains "NO_COLOR support" 'src/platforms/windows/core/logging.psm1' 'NO_COLOR'

# Summary
Write-Host "========================================="
Write-Host "Results: $Passed passed, $Failed failed, $Total total"
Write-Host "========================================="
if ($Failed -eq 0) { exit 0 } else { exit 1 }
```

### Example 3: Fixing terminal-setup.sh curl|sh Dry-Run Bypass

```bash
# BEFORE (broken -- run() only guards curl, pipe runs unconditionally):
run curl -sSfL https://raw.githubusercontent.com/ajeetdsouza/zoxide/main/install.sh | sh

# AFTER (correct -- entire pipeline guarded):
if [[ "$DRY_RUN" != "true" ]]; then
    curl -sSfL https://raw.githubusercontent.com/ajeetdsouza/zoxide/main/install.sh | sh
else
    log_dry "install zoxide via curl|sh"
fi
```

### Example 4: homebrew.sh Exit Code Fix

```bash
# BEFORE (exit 0 masks failure):
if ! install_homebrew; then
    log_error "Homebrew installation failed"
    exit 0  # Always exit 0 (per Phase 1 decision)
fi

# AFTER (exception for hard prerequisite):
if ! install_homebrew; then
    log_error "Homebrew installation failed"
    # Exception to always-exit-0: Homebrew is a hard prerequisite
    # for all subsequent macOS installs. Signal failure to caller.
    if [[ -n "${FAILURE_LOG:-}" ]]; then
        echo "homebrew-install" >> "$FAILURE_LOG"
    fi
    exit 1
fi
```

### Example 5: PowerShell FAILURE_LOG Integration

```powershell
# In errors.psm1, add file-based tracking alongside array:
function Add-FailedItem {
    param([Parameter(Mandatory)] [string]$Item)
    $script:FailedItems += $Item
    Write-Log -Level ERROR -Message "Failed: $Item"

    # Cross-process tracking via shared file
    if ($env:FAILURE_LOG -and (Test-Path (Split-Path $env:FAILURE_LOG))) {
        Add-Content -Path $env:FAILURE_LOG -Value $Item -Encoding UTF8
    }
}
```

### Example 6: Orchestrator Failure Aggregation (macOS main.sh)

```bash
# In macOS main.sh cleanup function, add FAILURE_LOG reading:
cleanup() {
    local exit_code=$?

    # Aggregate failures from child processes
    if [[ -n "${FAILURE_LOG:-}" && -f "$FAILURE_LOG" && -s "$FAILURE_LOG" ]]; then
        log_warn "Child process failures detected:"
        while IFS= read -r item; do
            echo "  - $item"
        done < "$FAILURE_LOG"
    fi

    [[ $exit_code -ne 0 ]] && log_info "Exiting ${SCRIPT_NAME} with code $exit_code"
    exit $exit_code
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `apt-key add -` | `/etc/apt/keyrings/` signed-by | apt 2.4 (2022) | post_install.sh uses deprecated method |
| `chmod 777` | Restrictive permissions (750/755) | Always bad | post_install.sh line 207 |
| Hardcoded package arrays | Data-driven `load_packages()` | Phase 2 (2026-02-05) | post_install.sh was partially migrated |
| Per-script exit codes | `FAILURE_LOG` file tracking | Phase 7 (2026-02-07) | setup.sh uses it, orchestrators don't |
| `select` for menus | `read`/`case` (Bash 3.2 compat) | Phase 4 (2026-02-06) | All menus already migrated |

**Deprecated/outdated:**
- `post_install.sh`: 100% superseded by linux/main.sh + child installers. Contains 10+ bugs. Deprecate.
- `apt-key`: Deprecated in apt 2.4. Not fixable in post_install.sh without rewrite (moot -- deprecating).

## Open Questions

1. **homebrew.sh exit code: exception or FAILURE_LOG?**
   - What we know: homebrew.sh currently exits 0 even on failure. macOS main.sh checks `|| return 1` which never triggers.
   - What's unclear: Should homebrew.sh be the ONLY exception to always-exit-0, or should all scripts adopt FAILURE_LOG?
   - Recommendation: Make homebrew.sh exit 1 on install failure (it is a hard prerequisite). Also write to FAILURE_LOG for belt-and-suspenders. This is a surgical exception, not a policy change.

2. **Windows cargo/npm/ai-tools installer scripts: scope of "dispatch"?**
   - What we know: Profiles list cargo.txt, npm.txt, ai-tools.txt. macOS and Linux dispatch them. Windows silently skips.
   - What's unclear: Does "dispatch" mean just WARN logging, or creating actual PS1 installer scripts?
   - Recommendation: WARN logging only for Phase 8.2. Creating full PowerShell cargo/npm/ai-tools installers is a separate future phase. The audit identified the SILENT skip as the problem, not the missing implementation.

3. **Should post_install.sh be deleted or deprecated?**
   - What we know: It has been in the codebase since 2022. test_harness.sh checks for its existence (line 57).
   - What's unclear: Whether users have direct references to this file path.
   - Recommendation: Deprecate-in-place (keep file, replace contents with notice). Update test_harness.sh to expect the deprecation notice.

## Sources

### Primary (HIGH confidence)
- Direct codebase analysis of all 30+ files in the repository
- `setup.sh` lines 47-48: FAILURE_LOG pattern already implemented
- `errors.sh` lines 72-76: record_failure() already writes to FAILURE_LOG when set
- `progress.sh` lines 105-109: show_completion_summary() already reads FAILURE_LOG
- `homebrew.sh` lines 181-183: exit 0 masking failure
- `terminal-setup.sh` lines 181, 188: curl|sh dry-run bypass
- `main.ps1` lines 74-84: switch block with only winget.txt handler
- Contributor Covenant v2.1: https://www.contributor-covenant.org/version/2/1/code_of_conduct/

### Secondary (MEDIUM confidence)
- None needed -- all findings are from direct code inspection

### Tertiary (LOW confidence)
- None

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Pure shell, no external deps, all patterns already in codebase
- Architecture: HIGH - All patterns identified from existing code, not hypothetical
- Pitfalls: HIGH - Each pitfall traced to specific line numbers in existing code

**Research date:** 2026-02-08
**Valid until:** 2026-03-08 (stable codebase, no external dependency drift)
