---
phase: 16-exit-codes-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/errors.sh
  - setup.sh
  - src/platforms/linux/main.sh
  - src/platforms/macos/main.sh
  - src/platforms/linux/install/apt.sh
  - src/platforms/linux/install/flatpak.sh
  - src/platforms/linux/install/snap.sh
  - src/platforms/linux/install/cargo.sh
  - src/platforms/macos/install/brew.sh
  - src/platforms/macos/install/brew-cask.sh
  - src/install/ai-tools.sh
  - src/install/dev-env.sh
  - src/install/rust-cli.sh
  - src/install/fnm.sh
  - src/install/uv.sh
  - setup.ps1
  - src/platforms/windows/main.ps1
  - src/platforms/windows/core/errors.psm1
  - src/platforms/windows/install/winget.ps1
  - src/platforms/windows/install/cargo.ps1
  - src/platforms/windows/install/npm.ps1
  - src/platforms/windows/install/ai-tools.ps1
  - .planning/adrs/ADR-001-error-resilience.md
  - tests/test-core-errors.bats
autonomous: true

must_haves:
  truths:
    - "A child script that has package failures exits with code 1, not 0"
    - "A child script that succeeds exits with code 0"
    - "Parent orchestrator (setup.sh) exits with the worst exit code from its children"
    - "Ctrl+C exits with code 130, not 0"
    - "ADR-001 documents the semantic exit code scheme while preserving continue-on-failure intent"
  artifacts:
    - path: "src/core/errors.sh"
      provides: "EXIT_SUCCESS, EXIT_PARTIAL_FAILURE, EXIT_CRITICAL constants and compute_exit_code() function"
      contains: "readonly EXIT_SUCCESS=0"
    - path: "src/platforms/windows/core/errors.psm1"
      provides: "PS exit constants and Get-ExitCode function"
      contains: "EXIT_SUCCESS"
    - path: ".planning/adrs/ADR-001-error-resilience.md"
      provides: "Amended ADR documenting semantic exit codes"
      contains: "Amended"
    - path: "tests/test-core-errors.bats"
      provides: "Tests for exit code constants and compute_exit_code"
      contains: "compute_exit_code"
  key_links:
    - from: "src/core/errors.sh"
      to: "all 11 child Bash scripts"
      via: "EXIT_SUCCESS/EXIT_PARTIAL_FAILURE constants sourced by children"
      pattern: "EXIT_PARTIAL_FAILURE"
    - from: "setup.sh"
      to: "linux/main.sh or macos/main.sh"
      via: "_worst_exit tracking after bash child invocation"
      pattern: "_worst_exit"
    - from: "src/core/errors.sh cleanup()"
      to: "compute_exit_code()"
      via: "cleanup calls compute_exit_code BEFORE cleanup_temp_dir"
      pattern: "compute_exit_code"
---

<objective>
Replace universal `exit 0` with semantic exit codes (0=success, 1=partial failure, 2=critical) across all Bash and PowerShell scripts, and propagate worst exit code through the parent-child chain.

Purpose: Enable automation callers (other scripts, CI, wrappers) to distinguish success from failure. Currently every script exits 0 regardless of outcome, making chaining impossible.

Output: 23 files updated with semantic exit codes. Constants + compute function in core modules. Parent orchestrators track worst child code. ADR-001 amended. Tests extended.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-exit-codes-security/16-RESEARCH.md
@src/core/errors.sh
@setup.sh
@src/platforms/linux/main.sh
@src/platforms/macos/main.sh
@src/platforms/windows/core/errors.psm1
@src/platforms/windows/main.ps1
@setup.ps1
@tests/test-core-errors.bats
@.planning/adrs/ADR-001-error-resilience.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add exit code constants, compute_exit_code(), and refactor cleanup/trap in core modules</name>
  <files>
    src/core/errors.sh
    src/platforms/windows/core/errors.psm1
    tests/test-core-errors.bats
  </files>
  <action>
**In `src/core/errors.sh`:**

1. Add three readonly constants AFTER the source-guard block (before retry_with_backoff):
```bash
readonly EXIT_SUCCESS=0
readonly EXIT_PARTIAL_FAILURE=1
readonly EXIT_CRITICAL=2
```

2. Add `compute_exit_code()` function AFTER `get_failure_count()` (around line 120):
```bash
compute_exit_code() {
    local fail_count=0
    if [[ -n "${FAILURE_LOG:-}" && -f "$FAILURE_LOG" && -s "$FAILURE_LOG" ]]; then
        fail_count=$(wc -l < "$FAILURE_LOG" | tr -d ' ')
    elif [[ ${#FAILED_ITEMS[@]} -gt 0 ]]; then
        fail_count=${#FAILED_ITEMS[@]}
    fi
    if [[ "$fail_count" -gt 0 ]]; then
        return $EXIT_PARTIAL_FAILURE
    fi
    return $EXIT_SUCCESS
}
```
Note: This function only computes 0 vs 1. Code 2 (critical) is set explicitly by callers for pre-flight failures.

3. Refactor `cleanup()` function to use computed exit code instead of hardcoded `exit 0`:
```bash
cleanup() {
    show_failure_summary
    compute_exit_code
    local _exit_code=$?
    cleanup_temp_dir
    exit "$_exit_code"
}
```
CRITICAL ordering: compute exit code BEFORE cleanup_temp_dir (which deletes FAILURE_LOG).

4. Add `signal_cleanup()` for INT/TERM separation:
```bash
signal_cleanup() {
    cleanup_temp_dir
    exit 130
}
```

5. Update `setup_error_handling()` to use separate traps:
```bash
setup_error_handling() {
    create_temp_dir
    trap cleanup EXIT
    trap signal_cleanup INT TERM
}
```

6. Update export line to include new functions and constants:
```bash
export -f compute_exit_code
export EXIT_SUCCESS EXIT_PARTIAL_FAILURE EXIT_CRITICAL
```

7. Update the comment on line 159 from "Per CONTEXT: Always exit 0" to "Semantic exit code based on failure state".

**In `src/platforms/windows/core/errors.psm1`:**

1. Add constants at module scope (after the `$script:FailedItems = @()` line):
```powershell
$script:EXIT_SUCCESS = 0
$script:EXIT_PARTIAL_FAILURE = 1
$script:EXIT_CRITICAL = 2
```

2. Add `Get-ExitCode` function AFTER `Get-FailureCount`:
```powershell
function Get-ExitCode {
    <#
    .SYNOPSIS
        Compute semantic exit code based on failure state.
    .OUTPUTS
        System.Int32 -- 0 (success) or 1 (partial failure)
    #>
    [CmdletBinding()]
    param()

    $count = Get-FailureCount
    if ($count -gt 0) {
        return $script:EXIT_PARTIAL_FAILURE
    }
    return $script:EXIT_SUCCESS
}
```

3. Update `Export-ModuleMember` to export new function and constants:
```powershell
Export-ModuleMember -Function Add-FailedItem, Show-FailureSummary, Get-FailureCount, Clear-Failures, Get-ExitCode -Variable EXIT_SUCCESS, EXIT_PARTIAL_FAILURE, EXIT_CRITICAL
```

4. Remove the comment "Always exit 0 - failures shown in summary (pragmatic approach)" on line 10. Replace with: "Tracks failed items, computes semantic exit codes (0=success, 1=partial, 2=critical)".

**In `tests/test-core-errors.bats`:**

Add 4 new tests AFTER the existing tests (after "cleanup_temp_dir removes directory"):

```bash
@test "EXIT_SUCCESS constant equals 0" {
    [ "$EXIT_SUCCESS" -eq 0 ]
}

@test "EXIT_PARTIAL_FAILURE constant equals 1" {
    [ "$EXIT_PARTIAL_FAILURE" -eq 1 ]
}

@test "EXIT_CRITICAL constant equals 2" {
    [ "$EXIT_CRITICAL" -eq 2 ]
}

@test "compute_exit_code returns 0 when no failures" {
    clear_failures
    compute_exit_code
    [ $? -eq 0 ]
}

@test "compute_exit_code returns 1 when failures exist" {
    record_failure "test-pkg"
    compute_exit_code
    [ $? -eq 1 ]
}
```
  </action>
  <verify>
Run: `cd /Users/bragatte/Documents/GitHub/os-postinstall-scripts && bats tests/test-core-errors.bats`
All tests pass (original 9 + new 5 = 14 total).

Manual check: `grep -c 'EXIT_SUCCESS\|EXIT_PARTIAL_FAILURE\|EXIT_CRITICAL' src/core/errors.sh` returns 6+ matches.
Manual check: `grep 'compute_exit_code' src/core/errors.sh` returns the function definition and export.
Manual check: `grep 'Get-ExitCode' src/platforms/windows/core/errors.psm1` returns function definition and export.
  </verify>
  <done>
Exit code constants (0/1/2) defined in errors.sh and errors.psm1. compute_exit_code() and Get-ExitCode functions exist and return correct codes. cleanup() in errors.sh uses computed code instead of hardcoded 0. INT/TERM traps separated from EXIT trap. 14 bats tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update all child scripts, parent orchestrators, and amend ADR-001</name>
  <files>
    src/platforms/linux/install/apt.sh
    src/platforms/linux/install/flatpak.sh
    src/platforms/linux/install/snap.sh
    src/platforms/linux/install/cargo.sh
    src/platforms/macos/install/brew.sh
    src/platforms/macos/install/brew-cask.sh
    src/install/ai-tools.sh
    src/install/dev-env.sh
    src/install/rust-cli.sh
    src/install/fnm.sh
    src/install/uv.sh
    src/platforms/linux/main.sh
    src/platforms/macos/main.sh
    setup.sh
    src/platforms/windows/install/winget.ps1
    src/platforms/windows/install/cargo.ps1
    src/platforms/windows/install/npm.ps1
    src/platforms/windows/install/ai-tools.ps1
    src/platforms/windows/main.ps1
    setup.ps1
    .planning/adrs/ADR-001-error-resilience.md
  </files>
  <action>
**Bash child scripts (11 files) -- Replace final `exit 0` with semantic exit:**

For EACH of these 11 files, find the final `exit 0` and replace with:
```bash
if [[ ${#FAILED_ITEMS[@]} -gt 0 ]]; then
    exit "${EXIT_PARTIAL_FAILURE:-1}"
else
    exit "${EXIT_SUCCESS:-0}"
fi
```
Use `:-1` and `:-0` fallbacks for safety in case constants are somehow unavailable.

Files and their exit 0 locations:
- `src/platforms/linux/install/apt.sh` -- last line
- `src/platforms/linux/install/flatpak.sh` -- last line
- `src/platforms/linux/install/snap.sh` -- last line
- `src/platforms/linux/install/cargo.sh` -- last line
- `src/platforms/macos/install/brew.sh` -- last line
- `src/platforms/macos/install/brew-cask.sh` -- last line
- `src/install/ai-tools.sh` -- last line
- `src/install/dev-env.sh` -- last line
- `src/install/rust-cli.sh` -- last line
- `src/install/fnm.sh` -- last line
- `src/install/uv.sh` -- last line

IMPORTANT: Do NOT touch `exit 1` lines in source-loading blocks (e.g., `source ... || exit 1`). Only change the final `exit 0` at the bottom of each script.

**Bash parent orchestrators (3 files):**

In `setup.sh`:
1. Add `_worst_exit=0` variable at top of file (after the FAILURE_LOG setup, around line 49).
2. Replace the `cleanup()` override (lines 51-64) with:
```bash
cleanup() {
    if [[ -z "${_SUMMARY_SHOWN:-}" ]]; then
        if [[ -n "${FAILURE_LOG:-}" && -f "$FAILURE_LOG" && -s "$FAILURE_LOG" ]]; then
            log_warn "Failures detected:"
            while IFS= read -r item; do
                echo "  - $item"
            done < "$FAILURE_LOG"
        else
            show_failure_summary
        fi
    fi
    cleanup_temp_dir
    exit "${_worst_exit:-0}"
}
```
3. Keep the same `trap cleanup EXIT INT TERM` on line 65 (setup.sh does NOT need signal separation because it delegates to errors.sh's trap setup via setup_error_handling; this override runs after).
4. After the `bash "$linux_main" "$profile"` call (line 173) and the `bash "$macos_main" "$profile"` call (line 182), add worst-code capture. Wrap each platform dispatch in the pattern:
```bash
bash "$linux_main" "$profile"
rc=$?
[[ $rc -gt $_worst_exit ]] && _worst_exit=$rc
```
Same for macos_main. Also update the `return 1` cases to set `_worst_exit=2` (pre-flight critical: handler not found).
5. After `verify_all` (line 165), add pre-flight critical exit:
```bash
verify_all
if [[ $? -ne 0 ]]; then
    _worst_exit="${EXIT_CRITICAL:-2}"
fi
```
Note: verify_all currently just logs warnings -- check if it returns non-zero. If it does not return non-zero on failure, leave this as a defensive check that has no effect now but will catch future changes.

In `src/platforms/linux/main.sh`:
1. Add `_worst_exit=0` after the source blocks.
2. In `install_profile()`, after EACH `bash` dispatch call, add:
```bash
rc=$?; [[ $rc -gt $_worst_exit ]] && _worst_exit=$rc
```
Apply to: apt.sh, flatpak.sh, snap.sh, cargo.sh, dev-env.sh, rust-cli.sh, ai-tools.sh dispatches.
3. At the end of `install_profile()`, add `return $_worst_exit`.
4. In the unattended mode section (line 215-216), replace `exit $?` with:
```bash
install_profile "$1"
exit $?
```
This already captures the return value from install_profile which now returns $_worst_exit.
5. Update `cleanup()` (lines 57-70): Replace `exit $exit_code` with `exit ${_worst_exit:-$exit_code}` to prefer tracked worst code.

In `src/platforms/macos/main.sh`:
Same pattern as linux/main.sh:
1. Add `_worst_exit=0` after source blocks.
2. In `install_profile()`, after each bash dispatch (homebrew.sh, brew.sh, brew-cask.sh, dev-env.sh, rust-cli.sh, ai-tools.sh), add `rc=$?; [[ $rc -gt $_worst_exit ]] && _worst_exit=$rc`.
3. At end of install_profile(), add `return $_worst_exit`.
4. Update cleanup() to use `${_worst_exit:-$exit_code}`.

**PowerShell child scripts (4 files) -- Replace final `exit 0` with semantic exit:**

For EACH of these 4 files, find the final `exit 0` and replace with:
```powershell
Show-FailureSummary
$exitCode = Get-ExitCode
exit $exitCode
```

Files: winget.ps1, cargo.ps1, npm.ps1, ai-tools.ps1.

NOTE: If the script already calls `Show-FailureSummary` before the exit, do NOT add a duplicate call. Just add the `Get-ExitCode` and `exit`.

**PowerShell parent orchestrators (2 files):**

In `src/platforms/windows/main.ps1`:
1. Add `$script:worstExit = 0` at the top (after Import-Module lines).
2. After each `& "$WindowsDir/install/..."` dispatch inside `Install-Profile`, add:
```powershell
if ($LASTEXITCODE -gt $script:worstExit) { $script:worstExit = $LASTEXITCODE }
```
3. In unattended mode (line 122), replace `exit 0` with `exit $script:worstExit`.
4. In interactive mode exits, keep `exit 0` for the "Exit" menu choice (user chose to quit).

In `setup.ps1`:
1. Add `$script:worstExit = 0` after the Import-Module lines.
2. After `& $MainScript -Profile $Profile` (line 71), add:
```powershell
if ($LASTEXITCODE -gt $script:worstExit) { $script:worstExit = $LASTEXITCODE }
```
3. Replace final `exit 0` (line 85) with `exit $script:worstExit`.
4. For the `exit 0` on line 74 (handler not found), change to `exit 2` (critical failure).

**Amend ADR-001:**

In `.planning/adrs/ADR-001-error-resilience.md`:
1. Change `**Status:** Accepted` to `**Status:** Amended`.
2. Add `**Amended:** 2026-02-21` and `**Amendment Phase:** 16` below the date.
3. In the Decision section, update the bullet "All scripts exit 0 regardless of individual package failures" to:
```
- Scripts exit with semantic codes: 0 (all succeeded), 1 (some failed), 2 (critical pre-flight failure). The continue-on-failure intent is preserved -- scripts still complete their run and show the failure summary. The exit code now REFLECTS the outcome instead of masking it.
```
4. Add a new section "## Amendment: Semantic Exit Codes (Phase 16)" at the end with a brief explanation that this extends the original decision without changing the continue-on-failure behavior.
  </action>
  <verify>
Run: `cd /Users/bragatte/Documents/GitHub/os-postinstall-scripts && bats tests/test-core-errors.bats`
All 14 tests pass.

Manual checks:
- `grep -r 'exit 0$' src/platforms/linux/install/ src/platforms/macos/install/ src/install/` â€” ai-tools.sh has 2 intentional `exit 0` paths (menu skip at ~line 221, load failure at ~line 228) that remain. Only the final exit 0 at end-of-script is migrated. Expect 2 matches in ai-tools.sh.
- `grep -r 'EXIT_PARTIAL_FAILURE' src/platforms/linux/install/apt.sh` returns a match.
- `grep '_worst_exit' setup.sh src/platforms/linux/main.sh src/platforms/macos/main.sh` returns matches in all 3 files.
- `grep 'worstExit' setup.ps1 src/platforms/windows/main.ps1` returns matches in both files.
- `grep -r 'exit 0$' src/platforms/windows/install/` returns NO matches.
- `grep 'Amended' .planning/adrs/ADR-001-error-resilience.md` returns a match.

Syntax check: `bash -n setup.sh && bash -n src/platforms/linux/main.sh && bash -n src/platforms/macos/main.sh` all pass.
  </verify>
  <done>
All 11 Bash child scripts exit with semantic code (not hardcoded 0). All 4 PowerShell child scripts exit with semantic code. Parent orchestrators (setup.sh, linux/main.sh, macos/main.sh, setup.ps1, main.ps1) track worst exit code from children. ADR-001 amended to document semantic exit codes while preserving continue-on-failure intent. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `bats tests/test-core-errors.bats` -- all 14 tests pass
2. `bash -n setup.sh` -- syntax OK
3. `bash -n src/core/errors.sh` -- syntax OK
4. `bash -n src/platforms/linux/main.sh` -- syntax OK
5. `bash -n src/platforms/macos/main.sh` -- syntax OK
6. `grep -r 'exit 0$' src/platforms/linux/install/ src/platforms/macos/install/ src/install/ src/platforms/windows/install/` -- no matches (all replaced)
7. `grep 'EXIT_SUCCESS\|EXIT_PARTIAL_FAILURE\|EXIT_CRITICAL' src/core/errors.sh` -- 6+ matches
8. `grep 'compute_exit_code' src/core/errors.sh` -- function exists
9. ADR-001 status is "Amended"
</verification>

<success_criteria>
- EXIT_SUCCESS=0, EXIT_PARTIAL_FAILURE=1, EXIT_CRITICAL=2 constants exist in errors.sh and errors.psm1
- compute_exit_code() returns 0 with no failures, 1 with failures
- All 11 Bash child scripts use semantic exit (not hardcoded exit 0 at end). Note: roadmap SC#3 says "9" but actual count is 11 Bash children -- homebrew.sh already has conditional exit, but the remaining 11 all had hardcoded exit 0.
- All 4 PowerShell child scripts use semantic exit (not hardcoded exit 0 at end)
- setup.sh, linux/main.sh, macos/main.sh track _worst_exit from children
- setup.ps1, windows/main.ps1 track $worstExit from children
- Ctrl+C exits 130 (signal_cleanup in errors.sh)
- ADR-001 amended with semantic exit code documentation
- 14 bats tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/16-exit-codes-security/16-01-SUMMARY.md`
</output>
