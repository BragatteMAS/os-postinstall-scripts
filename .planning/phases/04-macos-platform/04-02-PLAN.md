---
phase: 04-macos-platform
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/platforms/macos/install/brew.sh
  - src/platforms/macos/install/brew-cask.sh
autonomous: true

must_haves:
  truths:
    - "brew.sh installs all packages from data/packages/brew.txt"
    - "brew-cask.sh installs all packages from data/packages/brew-cask.txt"
    - "Already installed packages are skipped without reinstalling"
    - "Failed packages are tracked and reported in summary"
    - "DRY_RUN=true shows what would be installed without actually installing"
    - "Uses is_brew_installed() from core/idempotent.sh — no redefinition"
  artifacts:
    - path: "src/platforms/macos/install/brew.sh"
      provides: "Formula installer from brew.txt"
      exports: ["_brew_formula_install"]
    - path: "src/platforms/macos/install/brew-cask.sh"
      provides: "Cask installer from brew-cask.txt"
      exports: ["_brew_cask_install"]
  key_links:
    - from: "src/platforms/macos/install/brew.sh"
      to: "src/core/packages.sh"
      via: "load_packages call"
      pattern: "load_packages.*brew.txt"
    - from: "src/platforms/macos/install/brew-cask.sh"
      to: "src/core/packages.sh"
      via: "load_packages call"
      pattern: "load_packages.*brew-cask.txt"
---

<objective>
Create the Homebrew formula and cask installers that read from data files.

Purpose: Install packages from data/packages/brew.txt and brew-cask.txt using the same data-driven pattern as apt.sh.
Output: `src/platforms/macos/install/brew.sh` and `src/platforms/macos/install/brew-cask.sh`
</objective>

<execution_context>
@/Users/bragatte/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bragatte/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-macos-platform/04-RESEARCH.md

# Reference existing patterns
@src/platforms/linux/install/apt.sh
@src/core/packages.sh
@src/core/errors.sh
@data/packages/brew.txt
@data/packages/brew-cask.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create brew.sh formula installer</name>
  <files>src/platforms/macos/install/brew.sh</files>
  <action>
Create `src/platforms/macos/install/brew.sh` mirroring apt.sh pattern:

1. Header with script description, author, date
2. NO set -e (per Phase 1 decision)
3. SCRIPT_DIR detection and source core utilities:
   ```bash
   SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
   source "${SCRIPT_DIR}/../../../core/logging.sh"
   source "${SCRIPT_DIR}/../../../core/idempotent.sh"
   source "${SCRIPT_DIR}/../../../core/errors.sh"
   source "${SCRIPT_DIR}/../../../core/packages.sh"
   ```

4. Verify brew is installed at start:
   ```bash
   if ! command -v brew &>/dev/null; then
       log_error "Homebrew not found. Run install/homebrew.sh first."
       exit 1
   fi
   ```

5. **DO NOT redefine `is_brew_installed()`** — already exists in core/idempotent.sh (sourced above).
   Use it directly in the install helper.

6. `_brew_formula_install()` local helper function (underscore prefix = private):
   - Check if already installed via `is_brew_installed "$pkg"` from core
   - **DRY_RUN check** before actual install:
     ```bash
     if [[ "${DRY_RUN:-}" == "true" ]]; then
         log_info "[DRY_RUN] Would install formula: $pkg"
         return 0
     fi
     ```
   - Use `HOMEBREW_NO_INSTALL_UPGRADE=1 brew install "$pkg"` (inline env var)
   - log_debug for already installed
   - log_info, log_ok, log_error as appropriate

7. Main section:
   - log_banner "Homebrew Formulae Installer"
   - load_packages "brew.txt"
   - log_info showing count
   - Loop through PACKAGES array, call `_brew_formula_install` for each
   - `record_failure` from errors.sh for failures
   - `show_failure_summary` at end

8. Cleanup trap
9. Always exit 0 (per Phase 1)
10. Make executable

**CRITICAL:** DRY_RUN check uses `== "true"` (not `-n`). Per Phase 3 decision [03-04].
  </action>
  <verify>
1. `shellcheck src/platforms/macos/install/brew.sh` passes
2. `grep -q "load_packages.*brew.txt" src/platforms/macos/install/brew.sh` succeeds
3. `grep -q "HOMEBREW_NO_INSTALL_UPGRADE" src/platforms/macos/install/brew.sh` succeeds
4. `grep -q "DRY_RUN" src/platforms/macos/install/brew.sh` succeeds
5. `grep -qv "^is_brew_installed" src/platforms/macos/install/brew.sh` — does NOT redefine is_brew_installed (uses core)
  </verify>
  <done>
brew.sh created with data-driven installation from brew.txt, uses is_brew_installed() from core/idempotent.sh, DRY_RUN support, and failure tracking
  </done>
</task>

<task type="auto">
  <name>Task 2: Create brew-cask.sh cask installer</name>
  <files>src/platforms/macos/install/brew-cask.sh</files>
  <action>
Create `src/platforms/macos/install/brew-cask.sh` similar to brew.sh but for casks:

1. Same header and structure as brew.sh
2. Source same core utilities

3. Verify brew is installed at start

4. `_is_cask_installed()` local helper function:
   - Use `brew list --cask "$cask" &>/dev/null` for cask-specific check
   - Note: `is_brew_installed()` from core checks formulae only, casks need --cask flag

5. `_brew_cask_install()` local helper function (underscore prefix = private):
   - Check if already installed via `_is_cask_installed`
   - **DRY_RUN check** before actual install:
     ```bash
     if [[ "${DRY_RUN:-}" == "true" ]]; then
         log_info "[DRY_RUN] Would install cask: $cask"
         return 0
     fi
     ```
   - Use `HOMEBREW_NO_INSTALL_UPGRADE=1 brew install --cask "$cask"` command
   - Same logging pattern as brew.sh

6. Main section:
   - log_banner "Homebrew Cask Installer"
   - load_packages "brew-cask.txt"
   - Loop through PACKAGES, call `_brew_cask_install`
   - `record_failure` for failures

7. Same cleanup and exit pattern
8. Make executable

Key difference from brew.sh: Uses `--cask` flag and local `_is_cask_installed()` check.

**CRITICAL:** DRY_RUN check uses `== "true"` (not `-n`). Per Phase 3 decision [03-04].
  </action>
  <verify>
1. `shellcheck src/platforms/macos/install/brew-cask.sh` passes
2. `grep -q "load_packages.*brew-cask.txt" src/platforms/macos/install/brew-cask.sh` succeeds
3. `grep -q "brew install --cask" src/platforms/macos/install/brew-cask.sh` succeeds
4. `grep -q "DRY_RUN" src/platforms/macos/install/brew-cask.sh` succeeds
  </verify>
  <done>
brew-cask.sh created with data-driven installation from brew-cask.txt, DRY_RUN support, for GUI applications
  </done>
</task>

</tasks>

<verification>
1. Both files exist and are executable
2. Both shellcheck clean
3. Both source core utilities (packages.sh, errors.sh, logging.sh, idempotent.sh)
4. brew.sh loads brew.txt, brew-cask.sh loads brew-cask.txt
5. Both use HOMEBREW_NO_INSTALL_UPGRADE=1
6. Both have cleanup traps
7. Both always exit 0
8. Both respect DRY_RUN=true (log preview, no actual install)
9. brew.sh does NOT redefine is_brew_installed() (uses core/idempotent.sh)
</verification>

<success_criteria>
- brew.sh installs formulae from data/packages/brew.txt with idempotency
- brew-cask.sh installs casks from data/packages/brew-cask.txt with idempotency
- Pattern matches apt.sh closely (same logging, error handling, structure)
- HOMEBREW_NO_INSTALL_UPGRADE=1 prevents unwanted upgrades (inline env var)
- record_failure() tracks failed packages
- Scripts verify Homebrew exists before attempting installs
- DRY_RUN=true previews without installing (uses == "true" check)
- is_brew_installed() reused from core/idempotent.sh — NOT redefined locally
- Local helpers use underscore prefix (_brew_formula_install, _brew_cask_install)
</success_criteria>

<output>
After completion, create `.planning/phases/04-macos-platform/04-02-SUMMARY.md`
</output>
