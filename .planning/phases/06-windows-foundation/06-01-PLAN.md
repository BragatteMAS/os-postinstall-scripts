---
phase: 06-windows-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - setup.ps1
  - src/platforms/windows/core/logging.psm1
  - src/platforms/windows/core/packages.psm1
  - src/platforms/windows/core/errors.psm1
autonomous: true

must_haves:
  truths:
    - "setup.ps1 exists at project root and can be invoked with .\\setup.ps1"
    - "Colored logging output uses [OK]/[ERROR]/[WARN]/[INFO]/[DEBUG] format matching Bash"
    - "Package loading reads winget.txt skipping comments and blank lines"
    - "Failure tracking collects failed items and shows summary at end"
    - "All scripts use #Requires -Version 5.1 and no PS7-only features"
  artifacts:
    - path: "setup.ps1"
      provides: "Windows entry point that dispatches to main.ps1"
      contains: "#Requires -Version 5.1"
    - path: "src/platforms/windows/core/logging.psm1"
      provides: "Write-Log (single function with -Level parameter)"
      exports: "Write-Log"
    - path: "src/platforms/windows/core/packages.psm1"
      provides: "Read-PackageFile"
      exports: "Read-PackageFile"
    - path: "src/platforms/windows/core/errors.psm1"
      provides: "Add-FailedItem, Show-FailureSummary, Get-FailureCount, Clear-Failures"
      exports: "Add-FailedItem, Show-FailureSummary, Get-FailureCount, Clear-Failures"
  key_links:
    - from: "setup.ps1"
      to: "src/platforms/windows/main.ps1"
      via: "& $MainScript invocation"
      pattern: "main\\.ps1"
    - from: "src/platforms/windows/core/packages.psm1"
      to: "data/packages/"
      via: "Get-Content file path"
      pattern: "Get-Content.*packages"
---

<objective>
Create the PowerShell entry point (setup.ps1) and three core utility modules (logging, packages, errors) that mirror the Bash core infrastructure established in Phase 1.

Purpose: These modules provide the foundation for all Windows-specific scripts. Every subsequent PowerShell script will Import-Module these. Without them, the WinGet installer (Plan 02) has no logging, no package loading, and no failure tracking.

Output: setup.ps1 at project root + 3 .psm1 modules in src/platforms/windows/core/
</objective>

<execution_context>
@/Users/bragatte/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bragatte/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-windows-foundation/06-RESEARCH.md

# Existing patterns to mirror in PowerShell
@src/core/logging.sh
@src/core/packages.sh
@src/core/errors.sh
@config.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PowerShell core modules (logging, packages, errors)</name>
  <files>
    src/platforms/windows/core/logging.psm1
    src/platforms/windows/core/packages.psm1
    src/platforms/windows/core/errors.psm1
  </files>
  <action>
    Create three PowerShell modules that mirror the Bash core utilities 1:1 in behavior.

    **logging.psm1** - Mirror src/core/logging.sh:
    - Add `#Requires -Version 5.1` at top
    - Single `Write-Log` function with `-Level` and `-Message` parameters (PowerShell-idiomatic named params instead of 6 separate functions):
      ```powershell
      function Write-Log {
          param(
              [ValidateSet('OK','ERROR','WARN','INFO','DEBUG','BANNER')]
              [string]$Level = 'INFO',
              [string]$Message
          )
      }
      ```
    - `-Level` controls color: OK=Green, ERROR=Red, WARN=Yellow, INFO=Cyan, DEBUG=DarkGray, BANNER=Cyan
    - DEBUG only shown when `$env:VERBOSE -eq 'true'`
    - BANNER format: `"=== $Message ==="` (pass full banner text as Message)
    - Timestamp prefix when `$env:VERBOSE -eq 'true'` using `Get-Date -Format 'yyyy-MM-dd HH:mm:ss'`
    - Respect `$env:NO_COLOR`: if set, use `Write-Host` without `-ForegroundColor` (plain text)
    - Output: `Write-Host "[LEVEL]" -ForegroundColor $color -NoNewline` then `Write-Host " $prefix$Message"`
    - Export: `Export-ModuleMember -Function Write-Log`

    **packages.psm1** - Mirror src/core/packages.sh:
    - Add `#Requires -Version 5.1` at top
    - `$script:DataDir` — resolve project root via `Resolve-Path`, then join 'data':
      ```powershell
      $script:ProjectRoot = (Resolve-Path "$PSScriptRoot/../../../..").Path
      $script:DataDir = Join-Path $script:ProjectRoot 'data'
      ```
    - `Read-PackageFile` — takes `[string]$FileName` parameter. If not absolute path, resolve relative to `$script:DataDir/packages/`. Read file with `Get-Content -Encoding UTF8`, trim whitespace, skip blank lines and lines starting with `#`. Return string array of package names. If file not found, write warning and return empty array.
    - NO `Read-Profile` function — orchestrators (main.ps1) read profile files directly, matching how Linux main.sh works (line-by-line dispatch, no load_profile call). KISS: less abstraction, same behavior.
    - Export: `Read-PackageFile`

    **errors.psm1** - Mirror src/core/errors.sh:
    - Add `#Requires -Version 5.1` at top
    - `$script:FailedItems = @()` — simple array for failure tracking (for ~35 packages, `+=` performance is irrelevant; KISS over ArrayList/List)
    - `Add-FailedItem` — takes `[string]$Item`, appends to array (`$script:FailedItems += $Item`), calls `Write-Log -Level ERROR -Message "Failed: $Item"` (import logging module)
    - `Show-FailureSummary` — if count is 0, `Write-Log -Level OK -Message "All operations completed successfully"`. If count > 0, `Write-Log -Level WARN -Message "Summary: N item(s) failed"` then list each item with `"    - $item"` prefix via Write-Host.
    - `Get-FailureCount` — returns `$script:FailedItems.Count`
    - `Clear-Failures` — resets: `$script:FailedItems = @()`
    - Import logging module at top: `Import-Module "$PSScriptRoot/logging.psm1" -Force`
    - Export: `Add-FailedItem, Show-FailureSummary, Get-FailureCount, Clear-Failures`

    **CONSTRAINTS:**
    - PowerShell 5.1 ONLY: Do NOT use `??` (null-coalescing), `?:` (ternary), `ForEach-Object -Parallel`, or `Clean` block. Note: `$var = if (...) { } else { }` assignment IS valid in PS 5.1 (statement expression, not ternary)
    - Set `$ErrorActionPreference = 'Continue'` explicitly in every .ps1 script (not modules — modules inherit from caller)
    - Do NOT use `$ErrorActionPreference = 'Stop'` — match Bash "continue on failure" strategy
    - Use simple `@()` arrays for small collections — ArrayList/List unnecessary for <100 items
    - NO external modules (no Microsoft.WinGet.Client)
  </action>
  <verify>
    Run PowerShell syntax check on each module:
    `pwsh -NoProfile -Command "Get-Content 'src/platforms/windows/core/logging.psm1' | Out-Null; Write-Host 'logging.psm1 syntax OK'"` (or use `[System.Management.Automation.Language.Parser]::ParseFile()` for proper syntax validation)
    Verify each file starts with `#Requires -Version 5.1`
    Verify Export-ModuleMember is present in each module
  </verify>
  <done>
    Three .psm1 files exist in src/platforms/windows/core/ with:
    - logging.psm1 exports 1 function: Write-Log (single function with -Level parameter: OK, ERROR, WARN, INFO, DEBUG, BANNER)
    - packages.psm1 exports 1 function: Read-PackageFile (no Read-Profile — orchestrators read profiles directly)
    - errors.psm1 exports 4 functions: Add-FailedItem, Show-FailureSummary, Get-FailureCount, Clear-Failures (uses simple @() array)
    - All files have #Requires -Version 5.1
    - DataDir resolved via Resolve-Path (not fragile ../ chain)
    - No PS7-only syntax used
  </done>
</task>

<task type="auto">
  <name>Task 2: Create setup.ps1 Windows entry point</name>
  <files>
    setup.ps1
  </files>
  <action>
    Create `setup.ps1` at the project root as the Windows equivalent of `setup.sh`.

    Structure (mirror setup.sh behavior):
    ```
    #Requires -Version 5.1
    # setup.ps1 - Windows Post-Installation Entry Point
    ```

    - `param` block at top: `[string]$Profile = 'developer'`, `[switch]$Help`
    - `$ErrorActionPreference = 'Continue'` — explicit, first executable line after param
    - If `$Help`, print usage (mirror setup.sh -h output adapted for Windows) and `exit 0`
    - Resolve `$ScriptRoot` via `$PSScriptRoot` (automatic variable, always correct)
    - Import core modules:
      ```powershell
      Import-Module "$PSScriptRoot/src/platforms/windows/core/logging.psm1" -Force
      Import-Module "$PSScriptRoot/src/platforms/windows/core/errors.psm1" -Force
      ```
    - Call `Write-Log -Level BANNER -Message "OS Post-Install Scripts (Windows)"`
    - Call `Write-Log -Level INFO -Message "Profile: $Profile"`
    - Do NOT check WinGet here — WinGet detection belongs in winget.ps1 (each installer handles its own tool availability, matching setup.sh pattern which doesn't check apt/brew)
    - Resolve path to main.ps1: `$MainScript = Join-Path $PSScriptRoot 'src' 'platforms' 'windows' 'main.ps1'`
    - If main.ps1 exists: `& $MainScript -Profile $Profile`
    - If not: `Write-Log -Level ERROR -Message "Windows platform handler not found: $MainScript"` and `exit 0`
    - At end: `Show-FailureSummary`, `Write-Log -Level BANNER -Message "Setup Complete"`, `exit 0`

    **CONSTRAINTS:**
    - Do NOT use `Set-ExecutionPolicy` inside the script (permanent system change)
    - Add a comment at top: `# Run with: powershell -ExecutionPolicy Bypass -File .\setup.ps1`
    - Always `exit 0` (match Bash convention)
    - No PS7-only syntax
  </action>
  <verify>
    Verify setup.ps1 exists at project root
    Verify it contains `#Requires -Version 5.1`
    Verify it contains `$ErrorActionPreference = 'Continue'`
    Verify it contains `param(` block
    Verify it does NOT contain `Get-Command winget` (WinGet check is in winget.ps1)
    Verify it references `main.ps1`
    Verify it ends with `exit 0`
  </verify>
  <done>
    setup.ps1 exists at project root with:
    - Help flag support (-Help)
    - Profile parameter (default: developer)
    - $ErrorActionPreference = 'Continue' explicit
    - Dispatch to src/platforms/windows/main.ps1 (no WinGet check — that's winget.ps1's job)
    - Failure summary at end
    - Always exit 0
  </done>
</task>

</tasks>

<verification>
1. All 4 files exist: setup.ps1, logging.psm1, packages.psm1, errors.psm1
2. All files start with `#Requires -Version 5.1`
3. No PS7-only syntax: search for `??`, `?:`, `ForEach-Object -Parallel`, `Clean {`
4. logging.psm1 exports single Write-Log function with -Level parameter
5. packages.psm1 exports Read-PackageFile only (no Read-Profile)
6. setup.ps1 does NOT check for WinGet (that's winget.ps1's responsibility)
7. setup.ps1 has `$ErrorActionPreference = 'Continue'`
8. packages.psm1 resolves DataDir via Resolve-Path (not fragile ../ chain)
</verification>

<success_criteria>
- 3 PowerShell modules in src/platforms/windows/core/ with proper exports
- setup.ps1 at project root with profile parameter and dispatch to main.ps1
- setup.ps1 has $ErrorActionPreference = 'Continue' explicit
- All files PowerShell 5.1 compatible (no modern syntax)
- Logging: single Write-Log function with [OK], [ERROR], [WARN], [INFO], [DEBUG], [BANNER] levels
- Package loading reads from data/packages/ (shared with Bash)
</success_criteria>

<output>
After completion, create `.planning/phases/06-windows-foundation/06-01-SUMMARY.md`
</output>
