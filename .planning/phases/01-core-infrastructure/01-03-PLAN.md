---
phase: 01-core-infrastructure
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/lib/errors.sh
  - scripts/lib/logging.sh
autonomous: true

must_haves:
  truths:
    - "When a package fails, user sees clear error message and script continues"
    - "After completion, failed items are summarized"
    - "All output uses consistent colored logging (info=blue, success=green, error=red, warning=yellow)"
    - "Colors auto-disable when piped or NO_COLOR is set"
    - "Verbose mode shows timestamps"
  artifacts:
    - path: "scripts/lib/errors.sh"
      provides: "Error handling, trap, failure tracking"
      exports: ["setup_error_handling", "record_failure", "show_failure_summary", "cleanup", "FAILED_ITEMS"]
    - path: "scripts/lib/logging.sh"
      provides: "Colored logging with TTY detection"
      exports: ["setup_colors", "log_ok", "log_error", "log_warn", "log_info", "log_debug", "log_banner"]
  key_links:
    - from: "scripts/lib/errors.sh"
      to: "trap"
      via: "shell builtin"
      pattern: "trap cleanup EXIT INT TERM"
    - from: "scripts/lib/logging.sh"
      to: "tput, NO_COLOR"
      via: "terminal query"
      pattern: "tput colors|NO_COLOR"
---

<objective>
Create error handling and logging system that enables graceful failure recovery and consistent output.

Purpose: Scripts should continue on package failures, track what failed, and provide clear feedback with consistent formatting.
Output: `scripts/lib/errors.sh` for failure tracking, `scripts/lib/logging.sh` for colored output.
</objective>

<execution_context>
@/Users/bragatte/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bragatte/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-infrastructure/01-CONTEXT.md
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
@scripts/utils/logging.sh (existing implementation to refactor)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create logging module with color detection</name>
  <files>scripts/lib/logging.sh</files>
  <action>
Create `scripts/lib/logging.sh` implementing:

1. **setup_colors() function:**
   - Respect NO_COLOR environment variable (no-color.org standard)
   - Check if stdout is TTY: `[[ -t 1 ]]`
   - Check terminal supports colors: `tput colors >= 8`
   - If colors supported: set RED, GREEN, YELLOW, BLUE, GRAY, NC variables
   - If not: set all to empty string

2. **Logging functions** (per CONTEXT format [OK]/[ERROR]/[WARN]/[INFO]):
   - log_ok(message): `[OK] message` in green
   - log_error(message): `[ERROR] message` in red (to stderr)
   - log_warn(message): `[WARN] message` in yellow
   - log_info(message): `[INFO] message` in blue
   - log_debug(message): `[DEBUG] message` in gray (only if VERBOSE set)

3. **Timestamp support:**
   - Add timestamp only when VERBOSE is set
   - Format: `[YYYY-MM-DD HH:MM:SS]`

4. **Log file support:**
   - If LOG_FILE is set, also write to file (without colors)
   - Strip color codes when writing: `sed 's/\x1b\[[0-9;]*m//g'`

5. **Banner function:**
   - log_banner(name, version): Simple one-line banner

6. **Header requirements:**
   - Prevent multiple sourcing
   - NO set -e
   - Call setup_colors on source

Refactor from existing scripts/utils/logging.sh - remove set -euo pipefail, add TTY detection.
  </action>
  <verify>
```bash
source scripts/lib/logging.sh
log_ok "Success message"
log_error "Error message"
log_warn "Warning message"
log_info "Info message"
VERBOSE=1 log_debug "Debug with timestamp"
```
Should show colored output with correct prefixes.
  </verify>
  <done>
- setup_colors() auto-detects TTY and NO_COLOR
- All 5 log functions use correct colors and prefixes
- Verbose mode adds timestamps
- LOG_FILE writes without color codes
- No set -e in file
  </done>
</task>

<task type="auto">
  <name>Task 2: Create error handling module</name>
  <files>scripts/lib/errors.sh</files>
  <action>
Create `scripts/lib/errors.sh` implementing:

1. **Failure tracking:**
   - Declare array: `declare -a FAILED_ITEMS=()`
   - record_failure(item): Add item to FAILED_ITEMS array
   - show_failure_summary(): List all failed items if any

2. **Cleanup function:**
   - cleanup(): Clean temp files, show failure summary
   - Remove `${TEMP_DIR:-/tmp/os-postinstall-$$}` if exists
   - Call show_failure_summary
   - Exit 0 always (per CONTEXT decision)

3. **Trap setup:**
   - setup_error_handling(): Set trap on EXIT, INT, TERM
   - Create TEMP_DIR for operations that need temp files

4. **apt retry helper** (per RESEARCH pattern):
   - apt_install(packages...): Install with DPkg::Lock::Timeout=60
   - One retry on failure with 5s delay
   - Record failure if both attempts fail

5. **Header requirements:**
   - Prevent multiple sourcing
   - NO set -e
   - Source logging.sh for output

Per CONTEXT: Always exit 0, track failures for summary but don't stop execution.
  </action>
  <verify>
```bash
source scripts/lib/errors.sh
record_failure "test-package"
record_failure "another-package"
show_failure_summary
```
Should list both failed items.
  </verify>
  <done>
- FAILED_ITEMS array tracks failures
- cleanup() removes temp files and shows summary
- trap setup on EXIT/INT/TERM
- apt_install() has retry logic
- Always exits 0 even with failures
- No set -e in file
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration test of error and logging modules</name>
  <files>scripts/lib/errors.sh, scripts/lib/logging.sh</files>
  <action>
Test that both modules work together:

1. Source both modules
2. Verify colors work
3. Test failure tracking
4. Verify cleanup trap is set
5. Test that piped output has no colors:
   `source scripts/lib/logging.sh && log_info "test" | cat`

6. Test NO_COLOR works:
   `NO_COLOR=1 bash -c 'source scripts/lib/logging.sh && log_info "test"'`

Document test results.
  </action>
  <verify>
All integration tests pass:
- Colors show in terminal
- Colors stripped in pipe
- NO_COLOR disables colors
- Failure tracking works
- Cleanup trap is active
  </verify>
  <done>
- Both modules work together
- Color detection is accurate
- Error handling integrates with logging
  </done>
</task>

</tasks>

<verification>
1. `bash -c 'source scripts/lib/logging.sh && log_info "test"'` - Shows colored output
2. `bash -c 'source scripts/lib/logging.sh && log_info "test"' | cat` - No color codes in output
3. `NO_COLOR=1 bash -c 'source scripts/lib/logging.sh && log_info "test"'` - No colors
4. `bash -c 'source scripts/lib/errors.sh && trap -p EXIT'` - Shows cleanup trap
5. Neither file contains `set -e`
</verification>

<success_criteria>
1. scripts/lib/logging.sh exists with color auto-detection
2. scripts/lib/errors.sh exists with failure tracking
3. Log format matches CONTEXT: [OK], [ERROR], [WARN], [INFO], [DEBUG]
4. Colors: green=success, red=error, yellow=warn, blue=info, gray=debug
5. NO_COLOR and pipe detection work
6. Failure summary shows at end
7. Script exits 0 even with failures
8. No set -e in either file
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-03-SUMMARY.md`
</output>
