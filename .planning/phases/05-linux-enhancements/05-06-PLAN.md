---
phase: 05-linux-enhancements
plan: 06
type: execute
wave: 3
depends_on: ["05-01", "05-02", "05-03", "05-04", "05-05"]
files_modified:
  - src/platforms/linux/main.sh
  - tests/test-linux.sh
autonomous: true

must_haves:
  truths:
    - "Linux main.sh has profile menu: minimal, developer, full"
    - "Linux main.sh has dual-mode: CLI arg for unattended, interactive menu for manual"
    - "Profile dispatch reads profile file and case-matches on package file names"
    - "Non-Linux files (brew.txt, brew-cask.txt) are silently skipped"
    - "Orchestrator ensures dev-env runs before ai-tools (structural ordering)"
    - "LINUX_DIR used instead of SCRIPT_DIR to avoid packages.sh overwrite"
    - "Tests validate syntax and key function behavior"
  artifacts:
    - path: "src/platforms/linux/main.sh"
      provides: "Linux orchestrator with profile dispatch and macOS parity"
      contains: "LINUX_DIR"
    - path: "tests/test-linux.sh"
      provides: "Linux-specific tests for syntax and function validation"
      contains: "bash -n"
  key_links:
    - from: "src/platforms/linux/main.sh"
      to: "src/platforms/linux/install/apt.sh"
      via: "bash dispatch"
      pattern: "apt.sh"
    - from: "src/platforms/linux/main.sh"
      to: "src/install/dev-env.sh"
      via: "bash dispatch"
      pattern: "dev-env.sh"
    - from: "src/platforms/linux/main.sh"
      to: "src/install/ai-tools.sh"
      via: "bash dispatch"
      pattern: "ai-tools.sh"
    - from: "src/platforms/linux/main.sh"
      to: "data/packages/profiles/"
      via: "profile file reading"
      pattern: "profiles/"
---

<objective>
Rewrite the Linux main.sh orchestrator with profile-based dispatch matching macOS main.sh parity. Add dual-mode operation (CLI arg for unattended, interactive menu for manual), profile menu (minimal/developer/full), and platform-aware dispatch that routes package files to correct installers. Create practical tests.

Purpose: Complete the Linux platform enhancement by tying all new installers (apt, flatpak, snap, rust-cli, dev-env, ai-tools) together with profile-based orchestration.
Output: Rewritten `src/platforms/linux/main.sh` and `tests/test-linux.sh`.
</objective>

<execution_context>
@/Users/bragatte/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bragatte/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-linux-enhancements/05-CONTEXT.md
@.planning/phases/05-linux-enhancements/05-RESEARCH.md

Key reference files (critical):
@src/platforms/macos/main.sh (REFERENCE IMPLEMENTATION - follow this pattern closely)

Installers being dispatched:
@src/platforms/linux/install/apt.sh (--post flag support)
@src/platforms/linux/install/flatpak.sh (--post flag support, created in 05-02)
@src/platforms/linux/install/snap.sh (--post flag support, created in 05-02)
@src/platforms/linux/install/cargo.sh (existing)
@src/install/rust-cli.sh (cross-platform, created in 05-03)
@src/install/dev-env.sh (cross-platform, created in 05-04)
@src/install/ai-tools.sh (cross-platform, created in 05-05)

Profile files:
@data/packages/profiles/minimal.txt
@data/packages/profiles/developer.txt
@data/packages/profiles/full.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite Linux main.sh with profile dispatch</name>
  <files>src/platforms/linux/main.sh</files>
  <action>
  Complete rewrite of `src/platforms/linux/main.sh` following macOS main.sh pattern:

  1. Header (shebang, description, NOTE about no set -e)
  2. SCRIPT_NAME constant
  3. **LINUX_DIR** (NOT SCRIPT_DIR) -- critical to avoid packages.sh overwrite:
     ```
     LINUX_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
     readonly LINUX_DIR
     ```
  4. Source core utilities from `${LINUX_DIR}/../../core/`:
     - logging.sh, platform.sh, packages.sh, errors.sh
  5. Derive INSTALL_DIR for cross-platform installers:
     ```
     INSTALL_DIR="${LINUX_DIR}/../../install"
     ```
  6. DATA_DIR verification (same as macOS):
     ```
     if [[ -z "${DATA_DIR:-}" || ! -d "${DATA_DIR}" ]]; then
         DATA_DIR="$(cd "${LINUX_DIR}/../../data" 2>/dev/null && pwd -P)"
     fi
     ```
  7. Cleanup trap

  8. `show_menu()` function:
     ```
     echo ""
     echo -e "${BLUE}=======================================================${NC}"
     echo -e "${BLUE}         Linux Post-Installation Script                ${NC}"
     echo -e "${BLUE}=======================================================${NC}"
     echo ""
     echo "Select installation profile:"
     echo "  1. Minimal   (essential packages only)"
     echo "  2. Developer (system + dev tools + AI)"
     echo "  3. Full      (everything)"
     echo "  0. Exit"
     echo ""
     ```
     No emojis (per instructions). Clean, consistent with macOS menu.

  9. `install_profile()` function -- takes profile name as $1:
     - Validate profile file exists: `${DATA_DIR}/packages/profiles/${profile_name}.txt`
     `install_profile()` function — complete structure:

     ```
     install_profile() {
         local profile_name="$1"
         local profile_file="${DATA_DIR}/packages/profiles/${profile_name}.txt"

         if [[ ! -f "$profile_file" ]]; then
             log_error "Profile not found: $profile_name"
             return 1
         fi

         log_info "Profile: $profile_name"

         # For developer/full: install dev tools FIRST (provides Node.js for AI tools)
         if [[ "$profile_name" != "minimal" ]]; then
             log_info "Setting up development environment..."
             bash "${INSTALL_DIR}/dev-env.sh"

             log_info "Installing Rust CLI tools..."
             bash "${INSTALL_DIR}/rust-cli.sh"
         fi

         # Dispatch package files from profile
         while IFS= read -r pkg_file || [[ -n "$pkg_file" ]]; do
             pkg_file="${pkg_file#"${pkg_file%%[![:space:]]*}"}"
             [[ -z "$pkg_file" || "$pkg_file" == \#* ]] && continue

             case "$pkg_file" in
                 apt.txt)          bash "${LINUX_DIR}/install/apt.sh" ;;
                 apt-post.txt)     bash "${LINUX_DIR}/install/apt.sh" --post ;;
                 flatpak.txt)      bash "${LINUX_DIR}/install/flatpak.sh" ;;
                 flatpak-post.txt) bash "${LINUX_DIR}/install/flatpak.sh" --post ;;
                 snap.txt)         bash "${LINUX_DIR}/install/snap.sh" ;;
                 snap-post.txt)    bash "${LINUX_DIR}/install/snap.sh" --post ;;
                 cargo.txt)        bash "${LINUX_DIR}/install/cargo.sh" ;;
                 npm.txt)          log_debug "Skipping npm.txt (handled by dev-env)" ;;
                 ai-tools.txt)     bash "${INSTALL_DIR}/ai-tools.sh" ;;
                 brew.txt|brew-cask.txt)
                                   log_debug "Skipping $pkg_file (macOS only)" ;;
                 *)                log_warn "Unknown package file: $pkg_file" ;;
             esac
         done < "$profile_file"
     }
     ```

     Key ordering: dev-env.sh runs BEFORE the dispatch loop, guaranteeing Node.js
     is available when ai-tools.txt is encountered in the profile file.

  10. Dual-mode main section (match macOS exactly):
      - Check for CLI argument: `if [[ -n "${1:-}" ]]; then` -> unattended mode
      - Interactive mode: while true loop with show_menu + read + case

  NOTE: Do NOT include desktop-environments.sh in the dispatch. It's deferred/out of scope.

  NOTE: macOS main.sh currently skips cargo.txt and npm.txt with "requires Phase 5" comments.
  Phase 5 does NOT update macOS main.sh — those entries will remain skipped until a future
  macOS parity update. This is by design: Phase 5 focuses on Linux enhancements only.
  </action>
  <verify>Run `bash -n src/platforms/linux/main.sh` -- must pass syntax check. Verify file contains LINUX_DIR (not bare SCRIPT_DIR). Verify file contains all dispatch cases (apt, flatpak, snap, cargo, ai-tools, dev-env, rust-cli).</verify>
  <done>Linux main.sh has profile dispatch with macOS parity: menu, dual-mode, LINUX_DIR, all installer dispatch, dev-env before ai-tools ordering</done>
</task>

<task type="auto">
  <name>Task 2: Create Linux-specific tests</name>
  <files>tests/test-linux.sh</files>
  <action>
  Create `tests/test-linux.sh` with practical, limited tests:

  1. Header (shebang, description)
  2. Test runner setup:
     ```
     TESTS_PASSED=0
     TESTS_FAILED=0
     TESTS_TOTAL=0

     assert_pass() {
         local test_name="$1"; shift
         TESTS_TOTAL=$((TESTS_TOTAL + 1))
         if "$@" 2>/dev/null; then
             TESTS_PASSED=$((TESTS_PASSED + 1))
             echo "[PASS] $test_name"
         else
             TESTS_FAILED=$((TESTS_FAILED + 1))
             echo "[FAIL] $test_name"
         fi
     }
     # Usage: assert_pass "apt.sh syntax" bash -n src/platforms/linux/install/apt.sh
     ```

  3. Syntax validation tests (bash -n) — use descriptive name as first arg:
     - `assert_pass "apt.sh syntax" bash -n src/platforms/linux/install/apt.sh`
     - `assert_pass "flatpak.sh syntax" bash -n src/platforms/linux/install/flatpak.sh`
     - `assert_pass "snap.sh syntax" bash -n src/platforms/linux/install/snap.sh`
     - `assert_pass "linux main.sh syntax" bash -n src/platforms/linux/main.sh`
     - `assert_pass "rust-cli.sh syntax" bash -n src/install/rust-cli.sh`
     - `assert_pass "dev-env.sh syntax" bash -n src/install/dev-env.sh`
     - `assert_pass "fnm.sh syntax" bash -n src/install/fnm.sh`
     - `assert_pass "uv.sh syntax" bash -n src/install/uv.sh`
     - `assert_pass "ai-tools.sh syntax" bash -n src/install/ai-tools.sh`
     - `assert_pass "interactive.sh syntax" bash -n src/core/interactive.sh`

  4. Content validation tests (grep for critical patterns):
     - `assert_pass "APT lock handling" grep -q "DPkg::Lock::Timeout" src/platforms/linux/install/apt.sh`
     - `assert_pass "LINUX_DIR used" grep -q "LINUX_DIR" src/platforms/linux/main.sh`
     - `assert_pass "retry logic" grep -q "retry_with_backoff" src/platforms/linux/install/apt.sh`
     - `assert_pass "Flathub remote" grep -q "flathub" src/platforms/linux/install/flatpak.sh`
     - `assert_pass "classic confinement" grep -q "classic" src/platforms/linux/install/snap.sh`
     - `assert_pass "platform branching" grep -q "DETECTED_OS" src/install/rust-cli.sh`
     - `assert_pass "fnm URL" grep -q "fnm.vercel.app" src/install/fnm.sh`
     - `assert_pass "uv URL" grep -q "astral.sh" src/install/uv.sh`
     - `assert_pass "npm install" grep -q "npm install -g" src/install/ai-tools.sh`

  5. Anti-pattern tests (must NOT contain):
     - `assert_pass "no set -e in apt" ! grep -q "set -e" src/platforms/linux/install/apt.sh`
     - `assert_pass "no set -e in flatpak" ! grep -q "set -e" src/platforms/linux/install/flatpak.sh`
     - `assert_pass "no set -e in snap" ! grep -q "set -e" src/platforms/linux/install/snap.sh`
     - `assert_pass "no autoclean in apt" ! grep -q "autoclean" src/platforms/linux/install/apt.sh`
     - `assert_pass "no SCRIPT_DIR= in main" ! grep -q "^SCRIPT_DIR=" src/platforms/linux/main.sh`

  6. Summary:
     ```
     echo ""
     echo "Results: $TESTS_PASSED passed, $TESTS_FAILED failed, $TESTS_TOTAL total"
     [[ $TESTS_FAILED -eq 0 ]] && exit 0 || exit 1
     ```

  Make the test file executable: `chmod +x tests/test-linux.sh`
  </action>
  <verify>Run `bash -n tests/test-linux.sh` -- must pass syntax check. Run `bash tests/test-linux.sh` from the project root -- all syntax tests should pass (content/grep tests may vary based on exact implementation).</verify>
  <done>test-linux.sh validates syntax of all Phase 5 scripts, checks for critical patterns, and verifies anti-patterns are absent</done>
</task>

</tasks>

<verification>
- `bash -n src/platforms/linux/main.sh` exits 0
- `bash -n tests/test-linux.sh` exits 0
- `bash tests/test-linux.sh` from project root -- syntax tests pass
- Linux main.sh contains LINUX_DIR, not SCRIPT_DIR (except in comments)
- Linux main.sh dispatches to all installers: apt, flatpak, snap, cargo, ai-tools, dev-env, rust-cli
- Linux main.sh has dual-mode: CLI arg check + interactive menu loop
- Linux main.sh runs dev-env BEFORE ai-tools dispatch
- tests/test-linux.sh covers all 9 Phase 5 scripts
</verification>

<success_criteria>
Linux orchestrator has full macOS parity with profile-based dispatch, dual-mode operation, and correct execution ordering (dev-env before ai-tools). Tests validate syntax and critical patterns for all Phase 5 scripts.
</success_criteria>

<output>
After completion, create `.planning/phases/05-linux-enhancements/05-06-SUMMARY.md`
</output>
