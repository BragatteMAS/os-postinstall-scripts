---
phase: 05-linux-enhancements
plan: 06
type: execute
wave: 3
depends_on: ["05-01", "05-02", "05-03", "05-04", "05-05"]
files_modified:
  - src/platforms/linux/main.sh
  - tests/test-linux.sh
autonomous: true

must_haves:
  truths:
    - "Linux main.sh has profile menu: minimal, developer, full"
    - "Linux main.sh has dual-mode: CLI arg for unattended, interactive menu for manual"
    - "Profile dispatch reads profile file and case-matches on package file names"
    - "Non-Linux files (brew.txt, brew-cask.txt) are silently skipped"
    - "Orchestrator ensures dev-env runs before ai-tools (structural ordering)"
    - "LINUX_DIR used instead of SCRIPT_DIR to avoid packages.sh overwrite"
    - "Tests validate syntax and key function behavior"
  artifacts:
    - path: "src/platforms/linux/main.sh"
      provides: "Linux orchestrator with profile dispatch and macOS parity"
      contains: "LINUX_DIR"
    - path: "tests/test-linux.sh"
      provides: "Linux-specific tests for syntax and function validation"
      contains: "bash -n"
  key_links:
    - from: "src/platforms/linux/main.sh"
      to: "src/platforms/linux/install/apt.sh"
      via: "bash dispatch"
      pattern: "apt.sh"
    - from: "src/platforms/linux/main.sh"
      to: "src/install/dev-env.sh"
      via: "bash dispatch"
      pattern: "dev-env.sh"
    - from: "src/platforms/linux/main.sh"
      to: "src/install/ai-tools.sh"
      via: "bash dispatch"
      pattern: "ai-tools.sh"
    - from: "src/platforms/linux/main.sh"
      to: "data/packages/profiles/"
      via: "profile file reading"
      pattern: "profiles/"
---

<objective>
Rewrite the Linux main.sh orchestrator with profile-based dispatch matching macOS main.sh parity. Add dual-mode operation (CLI arg for unattended, interactive menu for manual), profile menu (minimal/developer/full), and platform-aware dispatch that routes package files to correct installers. Create practical tests.

Purpose: Complete the Linux platform enhancement by tying all new installers (apt, flatpak, snap, rust-cli, dev-env, ai-tools) together with profile-based orchestration.
Output: Rewritten `src/platforms/linux/main.sh` and `tests/test-linux.sh`.
</objective>

<execution_context>
@/Users/bragatte/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bragatte/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-linux-enhancements/05-CONTEXT.md
@.planning/phases/05-linux-enhancements/05-RESEARCH.md

Key reference files (critical):
@src/platforms/macos/main.sh (REFERENCE IMPLEMENTATION - follow this pattern closely)

Installers being dispatched:
@src/platforms/linux/install/apt.sh (--post flag support)
@src/platforms/linux/install/flatpak.sh (--post flag support, created in 05-02)
@src/platforms/linux/install/snap.sh (--post flag support, created in 05-02)
@src/platforms/linux/install/cargo.sh (existing)
@src/install/rust-cli.sh (cross-platform, created in 05-03)
@src/install/dev-env.sh (cross-platform, created in 05-04)
@src/install/ai-tools.sh (cross-platform, created in 05-05)

Profile files:
@data/packages/profiles/minimal.txt
@data/packages/profiles/developer.txt
@data/packages/profiles/full.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite Linux main.sh with profile dispatch</name>
  <files>src/platforms/linux/main.sh</files>
  <action>
  Complete rewrite of `src/platforms/linux/main.sh` following macOS main.sh pattern:

  1. Header (shebang, description, NOTE about no set -e)
  2. SCRIPT_NAME constant
  3. **LINUX_DIR** (NOT SCRIPT_DIR) -- critical to avoid packages.sh overwrite:
     ```
     LINUX_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
     readonly LINUX_DIR
     ```
  4. Source core utilities from `${LINUX_DIR}/../../core/`:
     - logging.sh, platform.sh, packages.sh, errors.sh
  5. Derive INSTALL_DIR for cross-platform installers:
     ```
     INSTALL_DIR="${LINUX_DIR}/../../install"
     ```
  6. DATA_DIR verification (same as macOS):
     ```
     if [[ -z "${DATA_DIR:-}" || ! -d "${DATA_DIR}" ]]; then
         DATA_DIR="$(cd "${LINUX_DIR}/../../data" 2>/dev/null && pwd -P)"
     fi
     ```
  7. Cleanup trap

  8. `show_menu()` function:
     ```
     echo ""
     echo -e "${BLUE}=======================================================${NC}"
     echo -e "${BLUE}         Linux Post-Installation Script                ${NC}"
     echo -e "${BLUE}=======================================================${NC}"
     echo ""
     echo "Select installation profile:"
     echo "  1. Minimal   (essential packages only)"
     echo "  2. Developer (system + dev tools + AI)"
     echo "  3. Full      (everything)"
     echo "  0. Exit"
     echo ""
     ```
     No emojis (per instructions). Clean, consistent with macOS menu.

  9. `install_profile()` function -- takes profile name as $1:
     - Validate profile file exists: `${DATA_DIR}/packages/profiles/${profile_name}.txt`
     - log_info "Profile: $profile_name"
     - Verify sudo: `verify_sudo` (from core, for apt/snap operations)
     - Read profile file line by line, skip comments/empty, trim whitespace
     - Case-match dispatch:
       ```
       apt.txt)         log_info "Installing APT packages..."
                        bash "${LINUX_DIR}/install/apt.sh" ;;
       apt-post.txt)    log_info "Installing APT post-install packages..."
                        bash "${LINUX_DIR}/install/apt.sh" --post ;;
       flatpak.txt)     log_info "Installing Flatpak packages..."
                        bash "${LINUX_DIR}/install/flatpak.sh" ;;
       flatpak-post.txt) log_info "Installing Flatpak post-install packages..."
                        bash "${LINUX_DIR}/install/flatpak.sh" --post ;;
       snap.txt)        log_info "Installing Snap packages..."
                        bash "${LINUX_DIR}/install/snap.sh" ;;
       snap-post.txt)   log_info "Installing Snap post-install packages..."
                        bash "${LINUX_DIR}/install/snap.sh" --post ;;
       cargo.txt)       log_info "Installing Cargo packages..."
                        bash "${LINUX_DIR}/install/cargo.sh" ;;
       npm.txt)         log_info "Skipping npm.txt (handled by dev-env)"
                        ;;
       ai-tools.txt)    log_info "Installing AI tools..."
                        bash "${INSTALL_DIR}/ai-tools.sh" ;;
       brew.txt|brew-cask.txt)
                        log_debug "Skipping $pkg_file (macOS only)" ;;
       *)               log_warn "Unknown package file: $pkg_file" ;;
       ```
     - IMPORTANT: After the profile file loop, add cross-platform installers that don't have a package file entry but are part of developer/full profiles:
       ```
       # Cross-platform tools (always after package file dispatch)
       if [[ "$profile_name" != "minimal" ]]; then
           log_info "Setting up development environment..."
           bash "${INSTALL_DIR}/dev-env.sh"

           log_info "Installing Rust CLI tools..."
           bash "${INSTALL_DIR}/rust-cli.sh"
       fi
       ```
       This ensures dev-env runs BEFORE ai-tools.txt is dispatched (structural ordering).

     Wait -- the profile file dispatch already handles ai-tools.txt. The ordering within the profile file matters. Since developer.txt lists packages in order and ai-tools.txt appears after other entries, we need to ensure dev-env.sh runs BEFORE the dispatch loop (or at the right point in the loop).

     REVISED approach: Run dev-env.sh and rust-cli.sh BEFORE the profile file dispatch loop for developer/full profiles. This guarantees Node.js is available when ai-tools.txt is dispatched.

     ```
     install_profile() {
         local profile_name="$1"
         local profile_file="${DATA_DIR}/packages/profiles/${profile_name}.txt"

         if [[ ! -f "$profile_file" ]]; then
             log_error "Profile not found: $profile_name"
             return 1
         fi

         log_info "Profile: $profile_name"

         # For developer/full: install dev tools first (provides Node.js for AI tools)
         if [[ "$profile_name" != "minimal" ]]; then
             log_info "Setting up development environment..."
             bash "${INSTALL_DIR}/dev-env.sh"

             log_info "Installing Rust CLI tools..."
             bash "${INSTALL_DIR}/rust-cli.sh"
         fi

         # Dispatch package files from profile
         while IFS= read -r pkg_file || [[ -n "$pkg_file" ]]; do
             pkg_file="${pkg_file#"${pkg_file%%[![:space:]]*}"}"
             [[ -z "$pkg_file" || "$pkg_file" == \#* ]] && continue

             case "$pkg_file" in
                 # ... dispatch cases as above ...
             esac
         done < "$profile_file"
     }
     ```

  10. Dual-mode main section (match macOS exactly):
      - Check for CLI argument: `if [[ -n "${1:-}" ]]; then` -> unattended mode
      - Interactive mode: while true loop with show_menu + read + case

  NOTE: Do NOT include desktop-environments.sh in the dispatch. It's deferred/out of scope.
  </action>
  <verify>Run `bash -n src/platforms/linux/main.sh` -- must pass syntax check. Verify file contains LINUX_DIR (not bare SCRIPT_DIR). Verify file contains all dispatch cases (apt, flatpak, snap, cargo, ai-tools, dev-env, rust-cli).</verify>
  <done>Linux main.sh has profile dispatch with macOS parity: menu, dual-mode, LINUX_DIR, all installer dispatch, dev-env before ai-tools ordering</done>
</task>

<task type="auto">
  <name>Task 2: Create Linux-specific tests</name>
  <files>tests/test-linux.sh</files>
  <action>
  Create `tests/test-linux.sh` with practical, limited tests:

  1. Header (shebang, description)
  2. Test runner setup:
     ```
     TESTS_PASSED=0
     TESTS_FAILED=0
     TESTS_TOTAL=0

     assert_pass() {
         TESTS_TOTAL=$((TESTS_TOTAL + 1))
         if "$@" 2>/dev/null; then
             TESTS_PASSED=$((TESTS_PASSED + 1))
             echo "[PASS] $1"
         else
             TESTS_FAILED=$((TESTS_FAILED + 1))
             echo "[FAIL] $1"
         fi
     }
     ```

  3. Syntax validation tests (bash -n):
     - `bash -n src/platforms/linux/install/apt.sh`
     - `bash -n src/platforms/linux/install/flatpak.sh`
     - `bash -n src/platforms/linux/install/snap.sh`
     - `bash -n src/platforms/linux/main.sh`
     - `bash -n src/install/rust-cli.sh`
     - `bash -n src/install/dev-env.sh`
     - `bash -n src/install/fnm.sh`
     - `bash -n src/install/uv.sh`
     - `bash -n src/install/ai-tools.sh`

  4. Content validation tests (grep for critical patterns):
     - `grep -q "DPkg::Lock::Timeout" src/platforms/linux/install/apt.sh` (APT lock handling)
     - `grep -q "LINUX_DIR" src/platforms/linux/main.sh` (correct variable name)
     - `grep -q "retry_with_backoff" src/platforms/linux/install/apt.sh` (retry logic)
     - `grep -q "flathub" src/platforms/linux/install/flatpak.sh` (Flathub remote)
     - `grep -q "classic" src/platforms/linux/install/snap.sh` (classic confinement)
     - `grep -q "DETECTED_OS" src/install/rust-cli.sh` (platform branching)
     - `grep -q "fnm.vercel.app" src/install/fnm.sh` (correct URL)
     - `grep -q "astral.sh" src/install/uv.sh` (correct URL)
     - `grep -q "npm install -g" src/install/ai-tools.sh` (npm install pattern)

  5. Anti-pattern tests (must NOT contain):
     - `! grep -q "set -e" src/platforms/linux/install/apt.sh` (no set -e)
     - `! grep -q "set -e" src/platforms/linux/install/flatpak.sh`
     - `! grep -q "set -e" src/platforms/linux/install/snap.sh`
     - `! grep -q "autoclean" src/platforms/linux/install/apt.sh` (no cleanup)
     - `! grep -q "SCRIPT_DIR" src/platforms/linux/main.sh` (must use LINUX_DIR)
       Exception: SCRIPT_DIR may appear in comments -- check for `^SCRIPT_DIR=` pattern instead

  6. Summary:
     ```
     echo ""
     echo "Results: $TESTS_PASSED passed, $TESTS_FAILED failed, $TESTS_TOTAL total"
     [[ $TESTS_FAILED -eq 0 ]] && exit 0 || exit 1
     ```

  Make the test file executable: `chmod +x tests/test-linux.sh`
  </action>
  <verify>Run `bash -n tests/test-linux.sh` -- must pass syntax check. Run `bash tests/test-linux.sh` from the project root -- all syntax tests should pass (content/grep tests may vary based on exact implementation).</verify>
  <done>test-linux.sh validates syntax of all Phase 5 scripts, checks for critical patterns, and verifies anti-patterns are absent</done>
</task>

</tasks>

<verification>
- `bash -n src/platforms/linux/main.sh` exits 0
- `bash -n tests/test-linux.sh` exits 0
- `bash tests/test-linux.sh` from project root -- syntax tests pass
- Linux main.sh contains LINUX_DIR, not SCRIPT_DIR (except in comments)
- Linux main.sh dispatches to all installers: apt, flatpak, snap, cargo, ai-tools, dev-env, rust-cli
- Linux main.sh has dual-mode: CLI arg check + interactive menu loop
- Linux main.sh runs dev-env BEFORE ai-tools dispatch
- tests/test-linux.sh covers all 9 Phase 5 scripts
</verification>

<success_criteria>
Linux orchestrator has full macOS parity with profile-based dispatch, dual-mode operation, and correct execution ordering (dev-env before ai-tools). Tests validate syntax and critical patterns for all Phase 5 scripts.
</success_criteria>

<output>
After completion, create `.planning/phases/05-linux-enhancements/05-06-SUMMARY.md`
</output>
