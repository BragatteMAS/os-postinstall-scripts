---
phase: 07-user-experience-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - setup.sh
  - src/platforms/linux/install/apt.sh
  - src/platforms/linux/install/flatpak.sh
  - src/platforms/linux/install/snap.sh
  - src/platforms/linux/install/cargo.sh
  - src/install/rust-cli.sh
  - src/install/fnm.sh
  - src/install/uv.sh
  - src/install/ai-tools.sh
  - src/install/dev-env.sh
autonomous: true

must_haves:
  truths:
    - "Running ./setup.sh --dry-run developer shows what would be installed without making any system changes"
    - "Running ./setup.sh -n shows the same dry-run behavior (short flag)"
    - "Running ./setup.sh --verbose enables debug output"
    - "Running ./setup.sh --unattended skips prompts"
    - "All 9 scripts that previously lacked DRY_RUN guards now log [DRY_RUN] Would... and return 0 instead of mutating"
    - "Flags can be combined with profile: ./setup.sh --dry-run --verbose developer"
  artifacts:
    - path: "setup.sh"
      provides: "CLI flag parsing before main()"
      contains: "--dry-run"
    - path: "src/platforms/linux/install/apt.sh"
      provides: "DRY_RUN guard in apt_hardened_install and safe_apt_update"
      contains: "DRY_RUN"
    - path: "src/platforms/linux/install/flatpak.sh"
      provides: "DRY_RUN guard in flatpak_install and ensure_flathub_remote"
      contains: "DRY_RUN"
    - path: "src/platforms/linux/install/snap.sh"
      provides: "DRY_RUN guard in snap_install"
      contains: "DRY_RUN"
    - path: "src/platforms/linux/install/cargo.sh"
      provides: "DRY_RUN guards in cargo_install, ensure_rust_installed, ensure_binstall"
      contains: "DRY_RUN"
    - path: "src/install/rust-cli.sh"
      provides: "DRY_RUN guards in install_rust_tools_linux, install_rust_tools_macos, create_rust_symlinks"
      contains: "DRY_RUN"
    - path: "src/install/fnm.sh"
      provides: "DRY_RUN guards in install_fnm, install_node_lts, install_global_npm"
      contains: "DRY_RUN"
    - path: "src/install/uv.sh"
      provides: "DRY_RUN guards in install_uv, install_python"
      contains: "DRY_RUN"
    - path: "src/install/ai-tools.sh"
      provides: "DRY_RUN guard in install_ai_tool (npm and curl branches)"
      contains: "DRY_RUN"
    - path: "src/install/dev-env.sh"
      provides: "DRY_RUN guard in setup_ssh_key"
      contains: "DRY_RUN"
  key_links:
    - from: "setup.sh"
      to: "config.sh"
      via: "export DRY_RUN=true overrides config.sh default"
      pattern: "export DRY_RUN=true"
---

<objective>
Implement --dry-run CLI flag parsing and add DRY_RUN guards to all scripts that mutate the system.

Purpose: Users need to preview what would happen before committing to installation (UX-02). Currently DRY_RUN is only settable via environment variable, and 9 scripts ignore it entirely. This plan makes dry-run mode discoverable via flags and comprehensive across all installers.

Output: setup.sh with flag parsing (--dry-run, --verbose, --unattended), 9 scripts with DRY_RUN guards at every mutation point.
</objective>

<execution_context>
@/Users/bragatte/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bragatte/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-user-experience-polish/07-RESEARCH.md

@setup.sh
@config.sh
@src/platforms/macos/install/brew.sh (reference: existing DRY_RUN pattern)
@src/platforms/linux/install/apt.sh
@src/platforms/linux/install/flatpak.sh
@src/platforms/linux/install/snap.sh
@src/platforms/linux/install/cargo.sh
@src/install/rust-cli.sh
@src/install/fnm.sh
@src/install/uv.sh
@src/install/ai-tools.sh
@src/install/dev-env.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CLI flag parsing to setup.sh</name>
  <files>setup.sh</files>
  <action>
Add a flag-parsing `while` loop BEFORE the `main "$@"` call at the bottom of setup.sh. This parses flags, shifts them off, then passes remaining args to main().

Insert between `setup_error_handling` and the `main()` function definition:

```bash
#-----------------------------------------------
# Parse CLI flags
#-----------------------------------------------
parse_flags() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--dry-run)
                export DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                export VERBOSE=true
                shift
                ;;
            -y|--unattended)
                export UNATTENDED=true
                shift
                ;;
            -h|--help)
                # Help is handled inside main(), just pass through
                break
                ;;
            -*)
                echo "[ERROR] Unknown option: $1" >&2
                echo "Usage: ./setup.sh [options] [action|profile]" >&2
                echo "Run './setup.sh --help' for details" >&2
                exit 1
                ;;
            *)
                break  # Non-flag argument = action or profile
                ;;
        esac
    done
    # Return remaining args for main()
    REMAINING_ARGS=("$@")
}
```

Then at the bottom of setup.sh, change:
```bash
main "$@"
```
to:
```bash
parse_flags "$@"
main "${REMAINING_ARGS[@]}"
```

Also update the help text inside main() to include the flags documentation:
```
Usage: ./setup.sh [options] [action|profile]

Options:
  -n, --dry-run     Show what would be done without making changes
  -v, --verbose     Enable debug output with timestamps
  -y, --unattended  Skip confirmation prompts
  -h, --help        Show this help message

Actions:
  dotfiles  Install dotfiles symlinks and zsh plugins
  unlink    Remove dotfiles symlinks and restore backups

Profiles:
  minimal    Essential tools only
  developer  Development environment (default)
  full       Everything
```

Critical notes:
- The `export` ensures child processes (bash "sub-script.sh") inherit the flag values
- This COMPLEMENTS the env var approach (DRY_RUN=true ./setup.sh still works via config.sh)
- Unknown flags (-*) cause immediate error (don't silently ignore)
- Non-flag args break out of the loop and are preserved for main()
  </action>
  <verify>
Run: `bash -n setup.sh` (syntax check passes)
Run: `bash setup.sh --help` (shows updated help with flags)
Run: `bash setup.sh --unknown-flag 2>&1` (shows error about unknown option)
Grep: `rg "parse_flags" setup.sh` (function exists)
Grep: `rg "\-\-dry-run" setup.sh` (flag recognized)
  </verify>
  <done>setup.sh accepts --dry-run/-n, --verbose/-v, --unattended/-y flags before profile/action argument</done>
</task>

<task type="auto">
  <name>Task 2: Add DRY_RUN guards to all 9 scripts missing them</name>
  <files>
    src/platforms/linux/install/apt.sh
    src/platforms/linux/install/flatpak.sh
    src/platforms/linux/install/snap.sh
    src/platforms/linux/install/cargo.sh
    src/install/rust-cli.sh
    src/install/fnm.sh
    src/install/uv.sh
    src/install/ai-tools.sh
    src/install/dev-env.sh
  </files>
  <action>
Add DRY_RUN guards to every system-mutating function in these scripts. Use the EXACT established pattern from brew.sh:

```bash
if [[ "${DRY_RUN:-}" == "true" ]]; then
    log_info "[DRY_RUN] Would install: $pkg"
    return 0
fi
```

**CRITICAL:** Use `== "true"` NOT `-n` (locked decision [03-04], config.sh sets DRY_RUN=false).

Place the guard AFTER the idempotency check (is_installed) but BEFORE the actual mutation command. This way, already-installed packages are still detected as skipped (not shown as "[DRY_RUN] Would install").

**Per-script mutation points:**

1. **apt.sh** - `apt_hardened_install()`: guard before `sudo apt-get install`. Also `safe_apt_update()`: guard before `sudo apt-get update`.
   - Log: `[DRY_RUN] Would apt install: $pkg` / `[DRY_RUN] Would run apt update`

2. **flatpak.sh** - `flatpak_install()`: guard before `flatpak install`. Also `ensure_flathub_remote()`: guard before `flatpak remote-add`.
   - Log: `[DRY_RUN] Would flatpak install: $app_id` / `[DRY_RUN] Would add Flathub remote`

3. **snap.sh** - `snap_install()`: guard before `sudo snap install`.
   - Log: `[DRY_RUN] Would snap install: $pkg`

4. **cargo.sh** - `cargo_install()`: guard before `cargo install` or `cargo binstall`. Also `ensure_rust_installed()`: guard before `curl | sh` (rustup). Also `ensure_binstall()`: guard before `cargo install cargo-binstall`.
   - Log: `[DRY_RUN] Would cargo install: $pkg` / `[DRY_RUN] Would install Rust via rustup` / `[DRY_RUN] Would install cargo-binstall`

5. **rust-cli.sh** - `install_rust_tools_linux()`: guard before `sudo apt-get install`. `install_rust_tools_macos()`: guard before `brew install`. `create_rust_symlinks()`: guard before `sudo ln -sf`.
   - Log: `[DRY_RUN] Would apt install: $pkg` / `[DRY_RUN] Would brew install: $pkg` / `[DRY_RUN] Would create symlink: $link`

6. **fnm.sh** - `install_fnm()`: guard before `curl | bash`. `install_node_lts()`: guard before `fnm install`. `install_global_npm()`: guard before `npm install -g`.
   - Log: `[DRY_RUN] Would install fnm` / `[DRY_RUN] Would install Node LTS` / `[DRY_RUN] Would npm install -g: $pkg`

7. **uv.sh** - `install_uv()`: guard before `curl | sh`. `install_python()`: guard before `uv python install`.
   - Log: `[DRY_RUN] Would install uv` / `[DRY_RUN] Would install Python via uv`

8. **ai-tools.sh** - `install_ai_tool()`: guard before `npm install -g` branch AND before `curl | sh` branch. Place guard inside the case branches, after idempotency check.
   - Log: `[DRY_RUN] Would npm install -g: $name` / `[DRY_RUN] Would curl-install: $name`

9. **dev-env.sh** - `setup_ssh_key()`: guard before `ssh-keygen`.
   - Log: `[DRY_RUN] Would generate SSH key`

Pattern placement within each function:
```bash
some_install() {
    local pkg="$1"

    # 1. Idempotency check (runs even in dry-run)
    if is_already_installed "$pkg"; then
        log_debug "Already installed: $pkg"
        return 0
    fi

    # 2. DRY_RUN guard (after idem check, before mutation)
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY_RUN] Would install: $pkg"
        return 0
    fi

    # 3. Actual mutation
    sudo apt-get install -y "$pkg"
}
```

Do NOT add DRY_RUN guards to:
- Idempotency checks (is_installed, command -v)
- Package loading (load_packages)
- Orchestrator-level dispatch (main.sh already doesn't check)
- Source/export statements
  </action>
  <verify>
Run: `rg "DRY_RUN" src/platforms/linux/install/apt.sh src/platforms/linux/install/flatpak.sh src/platforms/linux/install/snap.sh src/platforms/linux/install/cargo.sh` (all have DRY_RUN guards)
Run: `rg "DRY_RUN" src/install/rust-cli.sh src/install/fnm.sh src/install/uv.sh src/install/ai-tools.sh src/install/dev-env.sh` (all have DRY_RUN guards)
Run: `bash -n src/platforms/linux/install/apt.sh && bash -n src/platforms/linux/install/flatpak.sh && bash -n src/platforms/linux/install/snap.sh && bash -n src/platforms/linux/install/cargo.sh` (all pass syntax check)
Run: `bash -n src/install/rust-cli.sh && bash -n src/install/fnm.sh && bash -n src/install/uv.sh && bash -n src/install/ai-tools.sh && bash -n src/install/dev-env.sh` (all pass syntax check)
Run: `rg -- '-n "\$DRY_RUN"' src/` (no scripts use -n for DRY_RUN check -- would catch incorrect pattern)
  </verify>
  <done>All 9 scripts have DRY_RUN guards at every mutation point, using == "true" comparison, placed after idempotency checks</done>
</task>

</tasks>

<verification>
1. `bash -n setup.sh` -- no syntax errors
2. `bash setup.sh --help` -- shows flags in help text
3. `rg "DRY_RUN" src/platforms/linux/install/{apt,flatpak,snap,cargo}.sh | wc -l` -- at least 4 (one per file minimum)
4. `rg "DRY_RUN" src/install/{rust-cli,fnm,uv,ai-tools,dev-env}.sh | wc -l` -- at least 5 (one per file minimum)
5. All 10 modified files pass `bash -n` syntax check
6. `rg '== "true"' src/platforms/linux/install/{apt,flatpak,snap,cargo}.sh src/install/{rust-cli,fnm,uv,ai-tools,dev-env}.sh | wc -l` -- matches number of DRY_RUN guards (confirms correct comparison)
</verification>

<success_criteria>
- setup.sh parses --dry-run/-n, --verbose/-v, --unattended/-y before dispatching to main
- Unknown flags produce error message with exit 1
- All 9 scripts have DRY_RUN guards at mutation points
- DRY_RUN comparison uses == "true" (not -n)
- Guards are placed after idempotency checks, before mutations
- All modified files pass bash -n syntax check
- DRY_RUN=true still works via env var (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/07-user-experience-polish/07-02-SUMMARY.md`
</output>
