---
phase: 17-test-expansion-bash
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test-core-dotfiles.bats
  - tests/test-data-validation.bats
autonomous: true

must_haves:
  truths:
    - "dotfiles.sh path_to_backup_name converts dotfile paths to flat backup names with date suffix"
    - "dotfiles.sh backup_with_manifest creates backup dir, copies file, writes manifest, handles DRY_RUN"
    - "dotfiles.sh create_dotfile_symlink creates symlinks, backs up existing files, handles DRY_RUN"
    - "dotfiles.sh unlink_dotfiles removes symlinks and restores from manifest"
    - "dotfiles.sh show_backup_summary and list_backups handle empty state"
    - "All profile .txt files reference existing package files under data/packages/"
    - "No orphaned package files exist (every .txt in data/packages/ referenced by at least one profile)"
    - "All 3 expected profiles exist (minimal, developer, full)"
  artifacts:
    - path: "tests/test-core-dotfiles.bats"
      provides: "Unit tests for all 6 dotfiles.sh exported functions"
      min_lines: 200
    - path: "tests/test-data-validation.bats"
      provides: "Data integrity tests for profile and package files"
      min_lines: 60
  key_links:
    - from: "tests/test-core-dotfiles.bats"
      to: "src/core/dotfiles.sh"
      via: "source in setup() with HOME override"
      pattern: 'source.*dotfiles\.sh'
    - from: "tests/test-data-validation.bats"
      to: "data/packages/profiles/*.txt"
      via: "file iteration and reference checking"
      pattern: 'profiles.*\.txt'
---

<objective>
Create bats unit tests for dotfiles.sh (~18-22 tests) and data validation tests (~4-6 tests).

Purpose: dotfiles.sh is the most filesystem-intensive module -- every function creates, copies, symlinks, or removes files. All tests use tmpdir HOME isolation (verified in research). Data validation tests ensure profile integrity as a regression guard against broken package references.
Output: 2 new .bats files with ~22-28 total tests passing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-test-expansion-bash/17-RESEARCH.md

@tests/test-core-errors.bats
@src/core/dotfiles.sh
@src/core/logging.sh
@data/packages/profiles/minimal.txt
@data/packages/profiles/developer.txt
@data/packages/profiles/full.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test-core-dotfiles.bats (~18-22 tests)</name>
  <files>tests/test-core-dotfiles.bats</files>
  <action>
Create `tests/test-core-dotfiles.bats` following the tmpdir isolation pattern from research (Pattern 2).

**setup() function (CRITICAL -- HOME must be overridden BEFORE sourcing):**
```bash
setup() {
    export NO_COLOR=1
    unset _DOTFILES_SOURCED _LOGGING_SOURCED

    TEST_DIR="$(mktemp -d)"
    export HOME="${TEST_DIR}/home"
    mkdir -p "$HOME"

    # These MUST be set BEFORE sourcing dotfiles.sh (Pitfall 4: source-time expansion)
    export BACKUP_DIR="${HOME}/.dotfiles-backup"
    export MANIFEST_FILE="${BACKUP_DIR}/backup-manifest.txt"
    SESSION_BACKUPS=()

    source "${BATS_TEST_DIRNAME}/../src/core/logging.sh"
    source "${BATS_TEST_DIRNAME}/../src/core/dotfiles.sh"
}
```

**teardown():** `rm -rf "$TEST_DIR"`

**Tests to write:**

path_to_backup_name (4 tests):
1. `path_to_backup_name converts simple dotfile` - `run path_to_backup_name "$HOME/.zshrc"`, assert_output matches `zshrc.bak.YYYY-MM-DD` pattern (use regex: `[[ "$output" =~ ^zshrc\.bak\.[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]`)
2. `path_to_backup_name converts nested path` - `run path_to_backup_name "$HOME/.config/git/ignore"`, assert output matches `config-git-ignore.bak.YYYY-MM-DD`
3. `path_to_backup_name returns error for empty arg` - `run path_to_backup_name ""`, assert_failure
4. `path_to_backup_name includes date suffix` - `run path_to_backup_name "$HOME/.bashrc"`, assert_output --partial ".bak.$(date +%Y-%m-%d)"

backup_with_manifest (5 tests):
5. `backup_with_manifest creates backup directory` - create a file `$HOME/.testrc` with content "original", `run backup_with_manifest "$HOME/.testrc"`, assert_success, `[ -d "$BACKUP_DIR" ]`
6. `backup_with_manifest copies file to backup dir` - same setup, after backup, assert a .bak file exists in BACKUP_DIR
7. `backup_with_manifest writes to manifest file` - after backup, `[ -f "$MANIFEST_FILE" ]`, grep for ".testrc" in manifest
8. `backup_with_manifest handles name collision` - create file, backup once, backup again (same day), assert second backup has timestamp suffix (YYYY-MM-DD-HHMMSS pattern)
9. `backup_with_manifest skips in DRY_RUN mode` - DRY_RUN=true, create file, run backup, assert_success, assert no file was actually created in BACKUP_DIR (`[ ! -d "$BACKUP_DIR" ]` or BACKUP_DIR has no .bak files)
10. `backup_with_manifest fails on empty arg` - `run backup_with_manifest ""`, assert_failure

create_dotfile_symlink (6 tests):
11. `create_dotfile_symlink creates symlink` - create source file `$TEST_DIR/source/myconfig` with content, `run create_dotfile_symlink "$TEST_DIR/source/myconfig" "$HOME/.myconfig"`, assert_success, `[ -L "$HOME/.myconfig" ]`, verify readlink points to source
12. `create_dotfile_symlink backs up existing non-symlink file` - create `$HOME/.myconfig` with "old content", create source file, run create_dotfile_symlink, assert_success, `[ -L "$HOME/.myconfig" ]`, verify a backup exists in BACKUP_DIR
13. `create_dotfile_symlink replaces existing symlink without backup` - create a symlink at target pointing to /dev/null, run create_dotfile_symlink with real source, assert_success, `[ -L "$HOME/.myconfig" ]`, verify no backup was created (symlinks are replaced silently per code comment)
14. `create_dotfile_symlink creates parent directory` - target is `$HOME/.config/deep/nested/file`, run create_dotfile_symlink, assert_success, `[ -d "$HOME/.config/deep/nested" ]`
15. `create_dotfile_symlink fails for missing source` - `run create_dotfile_symlink "/nonexistent/path" "$HOME/.foo"`, assert_failure
16. `create_dotfile_symlink dry-run does not create symlink` - DRY_RUN=true, run with valid source and target, assert_success, `[ ! -L "$HOME/.myconfig" ]`

unlink_dotfiles (4 tests):
17. `unlink_dotfiles removes symlink` - create symlink, run unlink_dotfiles, assert_success, `[ ! -L "$target" ]`
18. `unlink_dotfiles restores backup from manifest` - create original file, backup it, create symlink, run unlink_dotfiles, assert the restored file exists and is NOT a symlink, verify content matches original
19. `unlink_dotfiles skips non-symlink files` - create regular file (not symlink), run unlink_dotfiles, assert_success (returns 0), verify file still exists unchanged
20. `unlink_dotfiles handles nonexistent target` - run unlink_dotfiles on path that doesn't exist, assert_success (returns 0)

show_backup_summary and list_backups (2 tests):
21. `show_backup_summary shows empty message when no backups` - SESSION_BACKUPS=(), run show_backup_summary, assert_output --partial "No backups created"
22. `list_backups shows message when no backup files exist` - run list_backups, assert_output --partial "No backup" (either "No backup directory" or "No backups found")

**CRITICAL implementation notes:**
- Every test that needs a source file must create it: `mkdir -p "$TEST_DIR/source" && echo "content" > "$TEST_DIR/source/myconfig"`
- For test 18 (restore from manifest), the setup is complex: create file, call `backup_with_manifest` directly (not via run -- so SESSION_BACKUPS and MANIFEST_FILE are populated in the same shell), then create symlink manually (`ln -sfn ... "$target"`), THEN `run unlink_dotfiles "$target"`
- For test 8 (name collision), both backups happen in the same second typically, so the collision handling kicks in
- `SESSION_BACKUPS` is a bash array, NOT exported. It works because `setup()` and tests run in the same subshell.
  </action>
  <verify>
Run: `./tests/lib/bats-core/bin/bats tests/test-core-dotfiles.bats`
All 18-22 tests pass (0 failures).
  </verify>
  <done>test-core-dotfiles.bats exists with 18+ passing tests covering path_to_backup_name, backup_with_manifest, create_dotfile_symlink, unlink_dotfiles, show_backup_summary, and list_backups. All tests use tmpdir HOME isolation.</done>
</task>

<task type="auto">
  <name>Task 2: Create test-data-validation.bats (~5-6 tests)</name>
  <files>tests/test-data-validation.bats</files>
  <action>
Create `tests/test-data-validation.bats` -- a data integrity test file that validates profile and package file consistency. NO module sourcing needed -- these are pure filesystem checks.

**setup() function:**
```bash
setup() {
    PROFILES_DIR="${BATS_TEST_DIRNAME}/../data/packages/profiles"
    PACKAGES_DIR="${BATS_TEST_DIRNAME}/../data/packages"
}
```

**Tests to write:**

1. `expected profiles exist (minimal, developer, full)` - assert `[ -f "$PROFILES_DIR/minimal.txt" ]`, same for developer.txt and full.txt

2. `all profile files reference existing package files` - iterate each .txt in PROFILES_DIR, for each non-comment non-empty line, assert `[ -f "$PACKAGES_DIR/$line" ]`. On failure: `fail "Profile $(basename $profile) references '$line' but $PACKAGES_DIR/$line does not exist"`

3. `no empty profiles - each has at least one package file reference` - for each profile, count non-comment non-empty lines, assert count > 0. On failure: `fail "Profile $(basename $profile) has no package file references"`

4. `no orphaned package files` - for each .txt file directly in PACKAGES_DIR (not in subdirectories), check that at least one profile references it. Use: `grep -rl "$(basename $pkg_file)" "$PROFILES_DIR/"`. On failure: `fail "Package file $(basename $pkg_file) is not referenced by any profile"`

5. `package files contain at least one package` - for each .txt in PACKAGES_DIR (not profiles/), count non-comment non-empty lines, assert > 0

6. `profile files are valid text with no binary content` - for each profile, run `file --mime-type "$profile"`, assert output contains "text/"

**Implementation notes:**
- Use `while IFS= read -r line` loop with proper trimming: `line="${line#"${line%%[![:space:]]*}"}"` then `[[ -z "$line" || "$line" == \#* ]] && continue`
- For test 4 (orphan check), the PROFILES_DIR/CLAUDE.md file is NOT a package file -- filter to only .txt files in PACKAGES_DIR root
- The `file --mime-type` check (test 6) guards against accidentally committing binary content to profile files
  </action>
  <verify>
Run: `./tests/lib/bats-core/bin/bats tests/test-data-validation.bats`
All 5-6 tests pass (0 failures).
  </verify>
  <done>test-data-validation.bats exists with 5+ passing tests validating profile existence, reference integrity, no orphans, non-empty content, and text format. Acts as regression guard for data/ directory.</done>
</task>

</tasks>

<verification>
Run all new test files together:
```bash
./tests/lib/bats-core/bin/bats tests/test-core-dotfiles.bats tests/test-data-validation.bats
```
Expected: ~23-28 tests, 0 failures.

Then run ALL tests to confirm no regressions:
```bash
./tests/lib/bats-core/bin/bats tests/test-core-*.bats tests/test-data-validation.bats
```
</verification>

<success_criteria>
- test-core-dotfiles.bats: 18+ tests passing (TEST-05)
- test-data-validation.bats: 5+ tests passing (TEST-07)
- All tests use tmpdir isolation for filesystem operations (no real HOME touched)
- All existing tests still pass (no regressions)
- Profile data integrity verified: no broken references, no orphans
</success_criteria>

<output>
After completion, create `.planning/phases/17-test-expansion-bash/17-02-SUMMARY.md`
</output>
