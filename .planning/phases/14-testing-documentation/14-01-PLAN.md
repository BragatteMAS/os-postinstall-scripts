---
phase: 14-testing-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test-core-logging.bats
  - tests/test-core-errors.bats
  - tests/test-core-idempotent.bats
  - tests/test-core-packages.bats
  - tests/fixtures/packages/test-apt.txt
  - tests/fixtures/packages/with-comments.txt
  - tools/lint.sh
  - tools/lint.ps1
  - .shellcheckrc
  - PSScriptAnalyzerSettings.psd1
  - .gitmodules
autonomous: true

must_haves:
  truths:
    - "Running `bats tests/test-core-logging.bats` passes all tests for log_ok, log_error, log_warn, log_info, log_debug, log_banner, and aliases"
    - "Running `bats tests/test-core-errors.bats` passes all tests for retry_with_backoff, record_failure, get_failure_count, clear_failures, show_failure_summary, create_temp_dir, cleanup_temp_dir"
    - "Running `bats tests/test-core-idempotent.bats` passes all tests for is_installed, ensure_line_in_file, ensure_dir, ensure_symlink, add_to_path, backup_if_exists"
    - "Running `bats tests/test-core-packages.bats` passes all tests for load_packages, load_profile, get_packages_for_manager"
    - "Running `bats tests/test-core-*.bats` executes all four test files and all pass"
    - "Running `bash tools/lint.sh` executes ShellCheck on all .sh files and reports OK/ISSUES per file"
    - "tools/lint.ps1 exists and is structured to run PSScriptAnalyzer on all .ps1/.psm1 files"
  artifacts:
    - path: "tests/test-core-logging.bats"
      provides: "Unit tests for logging.sh functions"
      contains: "@test.*log_ok"
    - path: "tests/test-core-errors.bats"
      provides: "Unit tests for errors.sh functions"
      contains: "@test.*retry_with_backoff"
    - path: "tests/test-core-idempotent.bats"
      provides: "Unit tests for idempotent.sh functions"
      contains: "@test.*is_installed"
    - path: "tests/test-core-packages.bats"
      provides: "Unit tests for packages.sh functions"
      contains: "@test.*load_packages"
    - path: "tests/fixtures/packages/test-apt.txt"
      provides: "Mock package list for packages.sh tests"
    - path: "tests/fixtures/packages/with-comments.txt"
      provides: "Package list with comments and blanks for filtering tests"
    - path: "tools/lint.sh"
      provides: "ShellCheck runner for all .sh files"
      contains: "shellcheck"
    - path: "tools/lint.ps1"
      provides: "PSScriptAnalyzer runner for all .ps1/.psm1 files"
      contains: "Invoke-ScriptAnalyzer"
    - path: ".shellcheckrc"
      provides: "ShellCheck config suppressing SC2034, SC1091 project-wide"
    - path: "PSScriptAnalyzerSettings.psd1"
      provides: "PSScriptAnalyzer config excluding PSAvoidUsingWriteHost"
  key_links:
    - from: "tests/test-core-logging.bats"
      to: "src/core/logging.sh"
      via: "source in setup()"
      pattern: "source.*logging\\.sh"
    - from: "tests/test-core-errors.bats"
      to: "src/core/errors.sh"
      via: "source in setup()"
      pattern: "source.*errors\\.sh"
    - from: "tests/test-core-idempotent.bats"
      to: "src/core/idempotent.sh"
      via: "source in setup()"
      pattern: "source.*idempotent\\.sh"
    - from: "tests/test-core-packages.bats"
      to: "src/core/packages.sh"
      via: "source in setup()"
      pattern: "source.*packages\\.sh"
    - from: "tests/test-core-packages.bats"
      to: "tests/fixtures/packages/"
      via: "DATA_DIR export in setup()"
      pattern: "DATA_DIR.*fixtures"
    - from: "tools/lint.sh"
      to: "src/"
      via: "find + shellcheck"
      pattern: "find.*shellcheck"
---

<objective>
Add bats-core unit tests for the four core Bash modules (logging.sh, errors.sh, idempotent.sh, packages.sh) and create local lint runner scripts (tools/lint.sh for ShellCheck, tools/lint.ps1 for PSScriptAnalyzer).

Purpose: Phase 14 is the final milestone v3.0 phase. Unit tests validate that the cleaned-up codebase from Phases 11-13 behaves correctly at the function level. Lint runners provide a repeatable quality check without CI/CD.

Output: 4 bats test files, 2 fixture files, 2 lint runner scripts, 2 lint config files, bats-core git submodules.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-testing-documentation/14-RESEARCH.md
@src/core/logging.sh
@src/core/errors.sh
@src/core/idempotent.sh
@src/core/packages.sh
@config.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install bats-core submodules and create test fixtures + unit tests for all 4 core modules</name>
  <files>
    tests/lib/bats-core (git submodule)
    tests/lib/bats-support (git submodule)
    tests/lib/bats-assert (git submodule)
    tests/fixtures/packages/test-apt.txt
    tests/fixtures/packages/with-comments.txt
    tests/test-core-logging.bats
    tests/test-core-errors.bats
    tests/test-core-idempotent.bats
    tests/test-core-packages.bats
  </files>
  <action>
**A. Add bats-core and helpers as git submodules:**

```bash
git submodule add https://github.com/bats-core/bats-core.git tests/lib/bats-core
git submodule add https://github.com/bats-core/bats-support.git tests/lib/bats-support
git submodule add https://github.com/bats-core/bats-assert.git tests/lib/bats-assert
```

**B. Create test fixture files:**

Create `tests/fixtures/packages/test-apt.txt` with 3-4 known package names (one per line, no comments):
```
curl
wget
git
jq
```

Create `tests/fixtures/packages/with-comments.txt` with a mix of packages, comments, and blank lines:
```
# This is a comment
curl

# Another comment
wget

git
```

**C. Create `tests/test-core-logging.bats`** (~90 lines)

Load bats helpers in each file:
```bash
load 'lib/bats-support/load'
load 'lib/bats-assert/load'
```

`setup()` function: `export NO_COLOR=1`, then `source "${BATS_TEST_DIRNAME}/../src/core/logging.sh"`. Each @test runs in a fresh subshell so the source guard resets automatically.

Tests to include (all use `run` + `assert_success`/`assert_output`):
1. `log_ok outputs [OK] prefix` -- `run log_ok "test message"`, assert_output --partial "[OK]", assert_output --partial "test message"
2. `log_error outputs [ERROR] prefix` -- `run log_error "bad thing"`, assert_output --partial "[ERROR]"
3. `log_warn outputs [WARN] prefix` -- `run log_warn "careful"`, assert_output --partial "[WARN]"
4. `log_info outputs [INFO] prefix` -- `run log_info "something"`, assert_output --partial "[INFO]"
5. `log_debug is silent when VERBOSE is not true` -- `unset VERBOSE`, `run log_debug "hidden"`, assert_output ""
6. `log_debug outputs when VERBOSE=true` -- `export VERBOSE=true`, `run log_debug "visible"`, assert_output --partial "[DEBUG]"
7. `log_debug is silent when VERBOSE=false` -- `export VERBOSE=false`, `run log_debug "hidden"`, assert_output ""
8. `setup_colors respects NO_COLOR` -- `export NO_COLOR=1`, `setup_colors`, then `[ -z "$RED" ]` and `[ -z "$GREEN" ]` and `[ -z "$NC" ]`
9. `backward compat aliases work` -- `run log "via alias"`, assert_output --partial "[INFO]"; `run log_success "via success"`, assert_output --partial "[OK]"
10. `log_banner includes name and version` -- `run log_banner "MyScript" "1.0"`, assert_output --partial "MyScript", assert_output --partial "v1.0"

**D. Create `tests/test-core-errors.bats`** (~100 lines)

`setup()` function: `export NO_COLOR=1`, source logging.sh first, then source errors.sh. Also `clear_failures` to reset state. Override sleep: `sleep() { :; }` to avoid real delays in retry_with_backoff tests. Set `FAILURE_LOG` to a temp file for cross-process tracking tests.

`teardown()` function: `rm -f "$FAILURE_LOG"` to clean up temp file.

Tests:
1. `record_failure increments failure count` -- `record_failure "test-pkg"`, then `[ "$(get_failure_count)" -eq 1 ]`
2. `multiple record_failure increments correctly` -- record 3 failures, `[ "$(get_failure_count)" -eq 3 ]`
3. `clear_failures resets count to zero` -- record 2 failures, `clear_failures`, `[ "$(get_failure_count)" -eq 0 ]`
4. `show_failure_summary lists failed items` -- record "pkg-a" and "pkg-b", then capture output directly (NOT with `run` â€” bash arrays don't propagate to subshells): `local output; output="$(show_failure_summary 2>&1)"`, then `[[ "$output" == *"2 item(s) failed"* ]]`, `[[ "$output" == *"pkg-a"* ]]`, `[[ "$output" == *"pkg-b"* ]]`
5. `show_failure_summary shows success when no failures` -- capture directly: `local output; output="$(show_failure_summary 2>&1)"`, then `[[ "$output" == *"All operations completed successfully"* ]]`
6. `retry_with_backoff succeeds on first try` -- `run retry_with_backoff true`, assert_success
7. `retry_with_backoff fails after max attempts` -- `run retry_with_backoff false`, assert_failure
8. `create_temp_dir creates a directory` -- `create_temp_dir`, `[ -d "$TEMP_DIR" ]`, then `cleanup_temp_dir`
9. `cleanup_temp_dir removes directory` -- `create_temp_dir`, save path, `cleanup_temp_dir`, `[ ! -d "$saved_path" ]`

IMPORTANT: The `sleep() { :; }` override must be declared inside `setup()` so it applies within each test's subshell. This prevents 20+ second delays from retry_with_backoff's hardcoded sleep calls.

IMPORTANT: For `retry_with_backoff` tests, the `sleep` override does NOT propagate into `run` because `run` executes in a subshell. Instead, test retry_with_backoff without `run` for the sleep-dependent failure path, or accept that the failure test takes ~20s. Alternative: define sleep as a function and `export -f sleep` in setup. Use `export -f sleep` approach.

**E. Create `tests/test-core-idempotent.bats`** (~100 lines)

`setup()`: `export NO_COLOR=1`, source idempotent.sh, create `TEST_TEMP="$(mktemp -d)"`.
`teardown()`: `rm -rf "$TEST_TEMP"`.

Tests:
1. `is_installed returns 0 for bash` -- `run is_installed bash`, assert_success
2. `is_installed returns 1 for nonexistent command` -- `run is_installed "definitely_not_a_real_command_xyz"`, assert_failure
3. `is_installed returns 1 for empty argument` -- `run is_installed ""`, assert_failure
4. `ensure_line_in_file adds line to new file` -- `run ensure_line_in_file "hello world" "${TEST_TEMP}/test.txt"`, assert_success, verify content with grep -c
5. `ensure_line_in_file is idempotent` -- add "hello" twice, grep -c returns "1"
6. `ensure_dir creates directory` -- `run ensure_dir "${TEST_TEMP}/newdir/sub"`, assert_success, `[ -d "${TEST_TEMP}/newdir/sub" ]`
7. `ensure_symlink creates symlink` -- create source file, `run ensure_symlink "$source" "$target"`, assert_success, `[ -L "$target" ]`
8. `add_to_path adds new path` -- save PATH, `add_to_path "/test/new/path"`, check `[[ ":$PATH:" == *":/test/new/path:"* ]]`, restore PATH
9. `add_to_path is idempotent` -- add twice, PATH unchanged after second call
10. `backup_if_exists creates backup of existing file` -- create file, `run backup_if_exists "$file"`, assert_success, check for .bak.* file
11. `backup_if_exists returns 0 for nonexistent file` -- `run backup_if_exists "${TEST_TEMP}/nope.txt"`, assert_success

**F. Create `tests/test-core-packages.bats`** (~80 lines)

`setup()`: `export NO_COLOR=1`, `export DATA_DIR="${BATS_TEST_DIRNAME}/fixtures"`, source logging.sh, then source packages.sh. The DATA_DIR pre-set ensures packages.sh uses test fixtures instead of real data/.

Tests:
1. `load_packages fails with no argument` -- `run load_packages`, assert_failure
2. `load_packages fails with nonexistent file` -- `run load_packages "nonexistent.txt"`, assert_failure
3. `load_packages reads packages from fixture file` -- `load_packages "test-apt.txt"`, then `[ "${#PACKAGES[@]}" -eq 4 ]` (curl, wget, git, jq)
4. `load_packages skips comments and blank lines` -- `load_packages "with-comments.txt"`, then `[ "${#PACKAGES[@]}" -eq 3 ]` (curl, wget, git -- no comments or blanks), also verify no entry starts with #
5. `get_packages_for_manager fails with no argument` -- `run get_packages_for_manager`, assert_failure
6. `get_packages_for_manager fails for unknown manager` -- `run get_packages_for_manager "nonexistent"`, assert_failure
7. `PACKAGES array is reset on each load_packages call` -- load test-apt.txt (4 pkgs), then load with-comments.txt (3 pkgs), `[ "${#PACKAGES[@]}" -eq 3 ]`

NOTE: The `tests/fixtures/` directory path must match: tests/fixtures/packages/ for package files. DATA_DIR points to tests/fixtures/, and load_packages resolves relative paths to DATA_DIR/packages/.
  </action>
  <verify>
    Run all bats tests:
    ```bash
    tests/lib/bats-core/bin/bats tests/test-core-*.bats
    ```
    All tests should pass (exit 0). Check individual files too:
    ```bash
    tests/lib/bats-core/bin/bats tests/test-core-logging.bats
    tests/lib/bats-core/bin/bats tests/test-core-errors.bats
    tests/lib/bats-core/bin/bats tests/test-core-idempotent.bats
    tests/lib/bats-core/bin/bats tests/test-core-packages.bats
    ```
    Verify fixtures exist: `ls tests/fixtures/packages/`
    Verify submodules: `git submodule status`
  </verify>
  <done>
    bats-core and helpers installed as git submodules in tests/lib/. Test fixtures exist in tests/fixtures/packages/. Four test files (test-core-logging.bats, test-core-errors.bats, test-core-idempotent.bats, test-core-packages.bats) exist and all pass when run via `bats tests/test-core-*.bats`. Tests cover: logging prefixes and VERBOSE gating, error tracking and retry logic, idempotent filesystem operations, and data-driven package loading with comment/blank filtering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create lint runner scripts and config files</name>
  <files>
    tools/lint.sh
    tools/lint.ps1
    .shellcheckrc
    PSScriptAnalyzerSettings.psd1
  </files>
  <action>
**A. Create `.shellcheckrc`** in project root (~5 lines):

```
# Project-wide ShellCheck configuration
# SC2034: Variable appears unused (false positive with export -f and cross-file usage)
# SC1091: Not following source (dynamic source paths cannot be resolved statically)
disable=SC2034,SC1091
```

**B. Create `PSScriptAnalyzerSettings.psd1`** in project root:

```powershell
@{
    # Write-Host is appropriate for CLI tools (not modules consumed by other scripts)
    ExcludeRules = @(
        'PSAvoidUsingWriteHost'
    )
}
```

**C. Create `tools/lint.sh`** (~50 lines):

```bash
#!/usr/bin/env bash
# tools/lint.sh -- Run ShellCheck on all .sh files
# Usage: bash tools/lint.sh
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
ERRORS=0
CHECKED=0

echo "=== ShellCheck ==="

# Find all .sh files in src/ and tests/ (excluding bats lib)
while IFS= read -r -d '' f; do
    CHECKED=$((CHECKED + 1))
    if shellcheck -x "$f" 2>&1; then
        echo "  OK: $(basename "$f")"
    else
        ERRORS=$((ERRORS + 1))
    fi
done < <(find "$PROJECT_ROOT/src" "$PROJECT_ROOT/tests" \
    -name '*.sh' -type f \
    -not -path '*/lib/*' \
    -print0 2>/dev/null)

# Also check root-level shell scripts
for rootfile in "$PROJECT_ROOT/setup.sh" "$PROJECT_ROOT/config.sh"; do
    if [ -f "$rootfile" ]; then
        CHECKED=$((CHECKED + 1))
        if shellcheck -x "$rootfile" 2>&1; then
            echo "  OK: $(basename "$rootfile")"
        else
            ERRORS=$((ERRORS + 1))
        fi
    fi
done

# Optional: shfmt check (only if installed)
if command -v shfmt >/dev/null 2>&1; then
    echo ""
    echo "=== shfmt ==="
    echo "  (shfmt detected, but formatting check is informational only)"
fi

echo ""
echo "=== Results ==="
echo "Checked: $CHECKED file(s)"
if [ $ERRORS -eq 0 ]; then
    echo "All files passed ShellCheck."
    exit 0
else
    echo "$ERRORS file(s) had issues."
    exit 1
fi
```

Make executable: `chmod +x tools/lint.sh`

Key decisions in the script:
- Uses `find ... -not -path '*/lib/*'` to exclude bats submodule .sh files from linting
- Uses `-x` flag for ShellCheck to follow source directives
- Reports individual file results (OK/ISSUES)
- Exits 0 on clean, 1 on issues (dev tool, not runtime -- exit codes are correct per ADR-001 note)
- shfmt section is informational only since shfmt is not installed

**D. Create `tools/lint.ps1`** (~45 lines):

```powershell
#Requires -Version 5.1
# tools/lint.ps1 -- Run PSScriptAnalyzer on all PowerShell files
# Usage: powershell -File tools/lint.ps1
$ProjectRoot = (Resolve-Path "$PSScriptRoot/..").Path
$SettingsFile = Join-Path $ProjectRoot 'PSScriptAnalyzerSettings.psd1'
$Errors = 0
$Checked = 0

Write-Host "=== PSScriptAnalyzer ===" -ForegroundColor Cyan

$files = @()
if (Test-Path "$ProjectRoot/src/platforms/windows") {
    $files += Get-ChildItem -Path "$ProjectRoot/src/platforms/windows" -Recurse -Include '*.ps1','*.psm1'
}
if (Test-Path "$ProjectRoot/setup.ps1") {
    $files += Get-Item "$ProjectRoot/setup.ps1"
}
if (Test-Path "$ProjectRoot/tests") {
    $files += Get-ChildItem -Path "$ProjectRoot/tests" -Filter '*.ps1'
}
if (Test-Path "$ProjectRoot/examples") {
    $files += Get-ChildItem -Path "$ProjectRoot/examples" -Filter '*.ps1'
}

$invokeArgs = @{ Severity = @('Warning', 'Error') }
if (Test-Path $SettingsFile) {
    $invokeArgs['Settings'] = $SettingsFile
}

foreach ($file in $files) {
    $Checked++
    $results = Invoke-ScriptAnalyzer -Path $file.FullName @invokeArgs
    if ($results) {
        Write-Host "  ISSUES: $($file.Name)" -ForegroundColor Yellow
        $results | Format-Table -Property Line, Severity, RuleName, Message -AutoSize
        $Errors++
    } else {
        Write-Host "  OK: $($file.Name)" -ForegroundColor Green
    }
}

Write-Host ""
Write-Host "=== Results ===" -ForegroundColor Cyan
Write-Host "Checked: $Checked file(s)"
if ($Errors -eq 0) {
    Write-Host "All files passed PSScriptAnalyzer." -ForegroundColor Green
    exit 0
} else {
    Write-Host "$Errors file(s) had issues." -ForegroundColor Yellow
    exit 1
}
```

Key decisions:
- Uses PSScriptAnalyzerSettings.psd1 if present (suppresses Write-Host warnings)
- Only checks Warning and Error severity (skips Information)
- Guards all path lookups with Test-Path for cross-platform safety
- Reports per-file results with Format-Table for issues
  </action>
  <verify>
    Run the ShellCheck lint runner:
    ```bash
    bash tools/lint.sh
    ```
    Confirm it finds .sh files, reports OK/ISSUES, and exits with a status code.

    Verify files exist:
    ```bash
    test -f .shellcheckrc && echo "OK: .shellcheckrc"
    test -f PSScriptAnalyzerSettings.psd1 && echo "OK: PSScriptAnalyzerSettings.psd1"
    test -f tools/lint.sh && echo "OK: tools/lint.sh"
    test -f tools/lint.ps1 && echo "OK: tools/lint.ps1"
    test -x tools/lint.sh && echo "OK: lint.sh executable"
    ```

    Verify .shellcheckrc content:
    ```bash
    grep -q 'SC2034' .shellcheckrc && echo "OK: SC2034 suppressed"
    grep -q 'SC1091' .shellcheckrc && echo "OK: SC1091 suppressed"
    ```
  </verify>
  <done>
    tools/lint.sh exists, is executable, and runs ShellCheck on all .sh files (excluding bats lib) reporting per-file results. tools/lint.ps1 exists and is structured to run PSScriptAnalyzer on all .ps1/.psm1 files. .shellcheckrc suppresses SC2034 and SC1091 project-wide. PSScriptAnalyzerSettings.psd1 disables PSAvoidUsingWriteHost rule. Running `bash tools/lint.sh` produces clean output with file-by-file results.
  </done>
</task>

</tasks>

<verification>
Phase 14 plan 01 (TEST-01 + TEST-02) verification:

1. `tests/lib/bats-core/bin/bats tests/test-core-*.bats` -- all four test files pass (TEST-01)
2. `bash tools/lint.sh` -- executes ShellCheck on all .sh files and reports results (TEST-02)
3. `test -f tools/lint.ps1` -- PSScriptAnalyzer runner exists (TEST-02)
4. `git submodule status` -- bats-core, bats-support, bats-assert listed
5. `ls tests/fixtures/packages/` -- test-apt.txt and with-comments.txt exist
6. `test -f .shellcheckrc` -- ShellCheck config exists
7. `test -f PSScriptAnalyzerSettings.psd1` -- PSScriptAnalyzer config exists
</verification>

<success_criteria>
- bats-core, bats-support, bats-assert installed as git submodules in tests/lib/
- tests/test-core-logging.bats passes (10 tests covering all log functions + aliases)
- tests/test-core-errors.bats passes (9 tests covering retry, failure tracking, temp dirs)
- tests/test-core-idempotent.bats passes (11 tests covering command checks, file ops, PATH)
- tests/test-core-packages.bats passes (7 tests covering load_packages, comment filtering, error paths)
- Running `bats tests/test-core-*.bats` executes all 37 tests and all pass
- tools/lint.sh runs ShellCheck on all .sh files, excludes bats lib, reports per-file results
- tools/lint.ps1 structured to run PSScriptAnalyzer on all .ps1/.psm1 files
- .shellcheckrc suppresses SC2034 and SC1091
- PSScriptAnalyzerSettings.psd1 disables PSAvoidUsingWriteHost
</success_criteria>

<output>
After completion, create `.planning/phases/14-testing-documentation/14-01-SUMMARY.md`
</output>
